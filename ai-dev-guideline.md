# AI駆動開発のための包括的ガイドライン

## 1. 目的と基本理念

本ガイドラインは、AI駆動開発を統制された情報フローの下で効率的に実施するための指針です。「すべてをまずは機械向けに正しく構造化し、必要に応じて人間向けに変換する」という基本理念に基づき、プロジェクト全体の一貫性と品質を確保します。

### 1.1 ブートストラップ問題への対応

AI駆動開発のガイドラインを導入する際に「ガイドライン自体の導入にもAIを活用したい」という循環的な状況が発生します。この「ブートストラップ問題」を解決するため、本ガイドラインでは段階的アプローチを採用し、最小限の基盤（フェーズ0）から始めて徐々に完全な実装へと発展させることを推奨します。

## 2. 導入フェーズの全体像

プロジェクトへのAI駆動開発導入は、以下のフェーズで段階的に行います：

```
フェーズ0（2週間）→ フェーズ1（4週間）→ フェーズ2（3週間）→ フェーズ3（3週間）→ フェーズ4（2週間）→ フェーズ5（3週間）
```

各フェーズの概要：
- **フェーズ0**: ミニマルAI駆動開発基盤の構築（ブートストラップ）
- **フェーズ1**: 情報フロー基盤の構築
- **フェーズ2**: DDD的な役割分離の導入
- **フェーズ3**: TDD（テスト駆動開発）の組み込み
- **フェーズ4**: 設計原則・手法のルール化
- **フェーズ5**: BDDとCI/CD連携の確立

## 3. フェーズ0：ミニマルAI駆動開発基盤の構築

### 3.1 目的と位置づけ

フェーズ0は、本格的なガイドライン導入前に最小限の仕組みを構築し、その後のフェーズをAI駆動で効率的に実装するための基盤となります。複雑なフレームワークやツールは使わず、シンプルなアプローチで迅速に導入できることを重視します。

### 3.2 コアコンポーネント

#### 3.2.1 タスク分解・追跡システム

**目的**: ユーザーからの大きな指示を、AIが処理可能な粒度のタスクに分解し追跡する仕組み

**ミニマル実装**:
```json
{
  "project": "ユーザー管理システム開発",
  "original_request": "ユーザー登録機能とプロフィール編集機能を実装してください",
  "decomposed_tasks": [
    {
      "id": "T001",
      "title": "ユーザーエンティティ設計",
      "description": "ユーザーの属性とメソッドを定義",
      "status": "completed",
      "dependencies": []
    },
    {
      "id": "T002",
      "title": "ユーザー登録API実装",
      "description": "新規ユーザー登録エンドポイントの作成",
      "status": "in_progress",
      "dependencies": ["T001"]
    },
    {
      "id": "T003",
      "title": "プロフィール編集API実装",
      "description": "既存ユーザー情報更新エンドポイントの作成",
      "status": "pending",
      "dependencies": ["T001"]
    }
  ],
  "current_focus": "T002"
}
```

**発展性**: フェーズ1でJSONスキーマによる検証を追加し、フェーズ2でDDDコンテキストに基づくタスク分類を導入、フェーズ5でCI/CDと連携させた自動タスク追跡へ発展。

#### 3.2.2 セッション間状態保持

**目的**: 複数のAI対話セッションをまたいで開発コンテキストを維持する仕組み

**ミニマル実装**:
```json
{
  "session_handover": {
    "project_id": "USER-SYS-2025",
    "session_timestamp": "2025-03-20T15:30:00Z",
    "project_state_summary": {
      "completed_tasks": ["T001"],
      "current_tasks": ["T002"],
      "pending_tasks": ["T003", "T004"]
    },
    "key_artifacts": {
      "User.ts": "User entity with email and password fields",
      "UserRepository.ts": "Interface for user persistence",
      "auth.ts": "Authentication utilities"
    },
    "current_challenges": [
      "Email validation needs improvement",
      "Password hashing implementation pending"
    ],
    "next_session_focus": "Complete T002 and begin T003"
  }
}
```

**発展性**: フェーズ1でより詳細な構造定義を追加、フェーズ3でテスト結果の継続的な引継ぎを含める、フェーズ5でバージョン管理システムと連携した状態管理へと発展。

#### 3.2.3 シンプルなフィードバックループ

**目的**: 実装結果の検証とそのフィードバックを開発フローに反映する基本的な仕組み

**ミニマル実装**:
```json
{
  "feedback_loop": {
    "task_id": "T002",
    "implementation_attempt": 1,
    "verification_results": {
      "passes_tests": false,
      "failed_tests": [
        {
          "test_name": "should_reject_invalid_email",
          "error": "Expected validation error but got success"
        }
      ],
      "suggestions": [
        "Add regex validation for email format",
        "Implement proper error handling for invalid inputs"
      ]
    },
    "iteration_plan": {
      "focus_areas": ["Email validation logic", "Error response formatting"],
      "approach": "Refactor validation method with regex pattern"
    }
  }
}
```

**発展性**: フェーズ3でTDDフローへの組み込み、フェーズ4で設計パターンとの整合性検証の追加、フェーズ5で自動テスト実行とフィードバック生成の仕組みへ発展。

#### 3.2.4 最小限の標準化テンプレート

**目的**: 基本的なコード構造とドキュメント形式を標準化し、一貫性を確保

**ミニマル実装**: 基本的なコードテンプレート例
```typescript
// エンティティテンプレート
export class Entity {
  constructor(private readonly id: string) {}
  
  public getId(): string {
    return this.id;
  }
}

// リポジトリインターフェーステンプレート
export interface Repository<T> {
  findById(id: string): Promise<T | null>;
  save(entity: T): Promise<void>;
  delete(id: string): Promise<void>;
}

// テストテンプレート
describe('Entity', () => {
  it('should create entity with valid id', () => {
    // テスト実装
  });
});
```

**発展性**: フェーズ1でJSONテンプレートの体系化、フェーズ2でDDDパターンの標準テンプレート追加、フェーズ4で高度な設計パターンをテンプレート化、フェーズ5でBDDシナリオテンプレートを統合。

### 3.3 フェーズ0実装ガイド

1. **環境準備**: シンプルなGitリポジトリを用意し、基本的なディレクトリ構造を作成
2. **テンプレート作成**: 最小限のコードテンプレートとドキュメントテンプレートを定義
3. **タスク管理**: タスク分解と追跡のためのJSONファイル形式を定義
4. **状態管理**: セッション間の状態引継ぎフォーマットを定義
5. **フィードバック**: シンプルなテスト実行と結果フィードバックの流れを確立

### 3.4 成功指標

- ユーザー指示を5分以内に実行可能なタスクに分解できる
- セッションを跨いでも開発コンテキストを90%以上維持できる
- テスト結果から自動的に修正方針を導出できる
- 基本的なコード生成が一貫した構造で行える

## 4. ステップバイステップ実装ガイド（フェーズ1-5）

### 4.1 フェーズ1: 情報フローの設計と実装

#### 4.1.1 フェーズ0からの発展

フェーズ0で構築したミニマル基盤を以下のように拡張します：

- **タスク分解・追跡**: JSONスキーマによる厳密な構造定義を追加
- **セッション間状態**: より詳細な構造化と検証メカニズムを導入
- **標準化テンプレート**: 包括的なJSONテンプレートライブラリに発展

#### 4.1.2 プロジェクトドキュメントのJSON化

**実装内容：**
- プロジェクト要件、非機能要件、ビジネス背景、ステークホルダー情報を包括的にJSON形式で文書化
- すべての仕様と制約を階層的に構造化

**具体的な手順：**
1. プロジェクト基本情報を定義するJSONテンプレートを作成
```json
{
  "project_name": "AI駆動開発プロジェクト",
  "version": "1.0.0",
  "last_updated": "2025-03-16",
  "business_context": {
    "overview": "...",
    "goals": ["...", "..."],
    "success_criteria": ["...", "..."]
  },
  "stakeholders": [
    {
      "role": "プロダクトオーナー",
      "responsibilities": ["要件定義", "優先順位付け"]
    },
    ...
  ],
  "non_functional_requirements": {
    "performance": {...},
    "security": {...},
    "scalability": {...}
  }
}
```

2. 機能要件をコンテキスト別にJSONファイルとして分割
3. バージョン管理システムにドキュメントを登録（ファイル命名規則：`<context>_requirements.json`）

#### 4.1.3 JSON Schemaによる構造・制約の定義

**実装内容：**
- すべてのJSONドキュメントに対応するJSON Schemaを作成
- 型チェック、必須項目、値の範囲などを定義

**具体的な手順：**
1. 各JSONドキュメントに対するスキーマファイルを作成（ファイル命名規則：`<document_name>.schema.json`）
2. 以下の要素を必ず含める：
   - 型定義（string, number, object, array など）
   - 必須プロパティ（required配列）
   - プロパティの制約（minLength, maxLength, pattern など）
   - 列挙型の場合は必ず許容値を明示（enum）

#### 4.1.4 JSON-RPCによるAIとのインターフェース定義

**実装内容：**
- AIへの指示（タスク実行リクエスト）をJSON-RPC 2.0形式で標準化
- よく使われるメソッドのカタログ化

**具体的な手順：**
1. プロジェクトで使用するJSON-RPCメソッドの一覧を定義
2. 各メソッドのパラメータ仕様をJSON Schemaで定義
3. レスポンス形式の標準化

#### 4.1.5 JSON Logicによる複雑なビジネスルールの定義

**実装内容：**
- 条件分岐を含む複雑なビジネスルールをJSON Logic形式で表現
- AIによる正確な解釈のための標準化

### 4.2 フェーズ2: DDD的な役割分離の組み込み

#### 4.2.1 フェーズ0・1からの発展

フェーズ0・1の基盤を以下のように発展させます：

- **タスク分解・追跡**: ドメインコンテキストに基づく分類を追加
- **セッション間状態**: ドメインモデルの状態管理を強化
- **標準化テンプレート**: DDDパターンに基づくテンプレートを追加

#### 4.2.2 境界付けられたコンテキストの定義

**実装内容：**
- プロジェクトの業務領域を「境界付けられたコンテキスト」として分割
- コンテキスト間の関係性を明示

**具体的な手順：**
1. コンテキストマップの作成
```json
{
  "contexts": [
    {
      "name": "ユーザー管理",
      "responsibility": "ユーザー登録、認証、権限管理",
      "ubiquitous_language": {
        "User": "システムにアクセスする個人または組織",
        "Role": "特定の権限セット",
        "Permission": "特定の操作を実行する能力"
      }
    },
    {
      "name": "コンテンツ管理",
      "responsibility": "記事、メディア、タグの管理",
      ...
    },
    ...
  ],
  "context_relationships": [
    {
      "source": "ユーザー管理",
      "target": "コンテンツ管理",
      "type": "UPSTREAM_DOWNSTREAM",
      "anti_corruption_layer": true
    },
    ...
  ]
}
```

#### 4.2.3 ユビキタス言語の定義と管理

**実装内容：**
- 各コンテキストの専門用語を定義
- JSONによる用語集の管理

### 4.3 フェーズ3: TDD（テスト駆動開発）の組み込み

#### 4.3.1 フェーズ0-2からの発展

フェーズ0-2の基盤を以下のように発展させます：

- **シンプルなフィードバックループ**: 本格的なTDDサイクルへ拡張
- **標準化テンプレート**: テスト優先のテンプレートに発展
- **セッション間状態**: テスト結果の継続的な追跡と引継ぎ

#### 4.3.2 テストファースト開発の仕組み化

**実装内容：**
- AIコード生成前のテストケース作成フローを確立
- テスト仕様のJSON形式での標準化

**具体的な手順：**
1. テスト仕様のJSON Schemaを定義
2. テスト生成用のJSON-RPCメソッドを定義
3. テスト生成→テスト確認→コード生成の順序を強制するワークフロー構築

#### 4.3.3 テスト自動化と継続的検証

**実装内容：**
- AIが生成したテストの自動実行環境の構築
- テストカバレッジ計測と品質指標の設定

### 4.4 フェーズ4: 設計原則・手法のルール化

#### 4.4.1 フェーズ0-3からの発展

フェーズ0-3の基盤を以下のように発展させます：

- **最小限の標準化テンプレート**: 高度な設計パターンを組み込んだテンプレートへ発展
- **タスク分解・追跡**: 設計原則に基づく評価基準を追加
- **フィードバックループ**: 設計品質の評価を組み込み

#### 4.4.2 採用する設計原則の明確化

**実装内容：**
- プロジェクトで採用する設計原則の定義
- AIコード生成時に適用すべき原則の標準化

#### 4.4.3 設計パターンの標準化

**実装内容：**
- プロジェクトで使用する設計パターンのカタログ作成
- パターン適用時の命名規則・実装規約の定義

### 4.5 フェーズ5: CI/CDやBDDの開発プロセス組み込み

#### 4.5.1 フェーズ0-4からの発展

フェーズ0-4の基盤を以下のように発展させます：

- **タスク分解・追跡**: CI/CDパイプラインと連携した自動化
- **セッション間状態**: バージョン管理システムと連携した状態管理
- **フィードバックループ**: 自動テスト実行とフィードバック生成
- **標準化テンプレート**: BDDシナリオテンプレートの統合

#### 4.5.2 継続的インテグレーション/デリバリーの構築

**実装内容：**
- AIと連携した自動化CI/CDパイプラインの設計
- バリデーション、テスト、デプロイの自動化

#### 4.5.3 振る舞い駆動開発（BDD）の導入

**実装内容：**
- ビジネスシナリオの構造化記述と自動テスト連携
- AI駆動で振る舞い仕様から実装へのフロー確立

## 5. プランニングフローの実装

プランニングフローは、アーキテクチャ図に基づいて以下のコンポーネントで構成します：

### 5.1 コンポーネント構成

```json
{
  "components": {
    "User": {
      "responsibility": "開発指示や要件の入力、結果の確認を行う人間のユーザー",
      "interfaces": ["execute"]
    },
    "PlanningFlow": {
      "responsibility": "全体のワークフローを管理し、ステップの進行を制御",
      "interfaces": ["execute", "createPlan", "processPlanCompletion"]
    },
    "PlanningTool": {
      "responsibility": "タスクの分解、ステップの生成、進捗管理を担当",
      "interfaces": ["createPlan", "getPlanInfo", "markStepComplete"]
    },
    "Executor": {
      "responsibility": "実際のタスク実行を担当し、LLMとの通信を行う",
      "interfaces": ["executeStep", "processResult"]
    },
    "LLM": {
      "responsibility": "AI処理の実行（コード生成、レビュー、ドキュメント生成等）",
      "interfaces": ["executeTask"]
    }
  }
}
```

### 5.2 情報フロー詳細定義

各フェーズで整備された情報フローを、プランニングフローのコンポーネント間連携に適用します。

## 6. 具体的な実装テンプレート

### 6.1 JSON-RPC リクエスト例（コード生成）

```json
{
  "jsonrpc": "2.0",
  "method": "generate_code",
  "params": {
    "context": "ユーザー管理",
    "entity": "User",
    "requirements": {
      "attributes": [
        {"name": "id", "type": "string", "required": true},
        {"name": "email", "type": "string", "required": true, "validation": "email"},
        {"name": "name", "type": "string", "required": true},
        {"name": "password", "type": "string", "required": true, "minLength": 8}
      ],
      "behaviors": [
        {"name": "register", "description": "新規ユーザー登録処理"},
        {"name": "authenticate", "description": "認証処理"},
        {"name": "updateProfile", "description": "プロフィール更新処理"}
      ],
      "constraints": [
        "メールアドレスはユニークであること",
        "パスワードは8文字以上で、英数字と特殊文字を含むこと"
      ]
    },
    "design_principles": ["SRP", "OCP"],
    "patterns": ["repository", "factory"],
    "output_language": "typescript",
    "architecture": "hexagonal"
  },
  "id": 1
}
```

### 6.2 JSON-RPC レスポンス例

レスポンス例略（前回提示した内容に相当）

## 7. プロジェクト管理と品質監視

### 7.1 メトリクス収集と分析

AI駆動開発の効果を測定するために、以下のメトリクスを収集・分析します：

```json
{
  "metrics": {
    "development_velocity": {
      "story_points_per_iteration": {"target": 20, "min_acceptable": 15},
      "code_generation_to_production_time": {"target": "2 days", "max_acceptable": "5 days"}
    },
    "quality": {
      "defect_rate": {"target": "< 0.5 per 1000 LOC", "max_acceptable": "2 per 1000 LOC"},
      "test_coverage": {"target": "> 90%", "min_acceptable": "80%"},
      "ai_code_acceptance_rate": {"target": "> 80%", "min_acceptable": "60%"}
    },
    "ai_effectiveness": {
      "prompt_iteration_count": {"target": "< 2", "max_acceptable": 4},
      "human_modification_ratio": {"target": "< 20%", "max_acceptable": "40%"}
    }
  }
}
```

### 7.2 フィードバックループの確立

各フェーズにおけるフィードバックループの発展を踏まえ、最終的な形態を実現します。

## 8. 段階的導入ロードマップ（更新版）

### 8.1 フェーズ0: ミニマルAI駆動開発基盤の構築（2週間）

**目的**: ブートストラップ問題を解決し、後続フェーズの実装基盤を整備

**タスク**:
- タスク分解・追跡システムの最小実装
- セッション間状態保持の仕組み構築
- シンプルなフィードバックループ確立
- 最小限の標準化テンプレート整備

**成功指標**:
- ユーザー指示を5分以内に実行可能なタスクに分解できる
- セッションを跨いで開発コンテキストを90%以上維持できる
- テスト結果から自動的に修正方針を導出できる
- 基本的なコード生成が一貫した構造で行える

### 8.2 フェーズ1: 情報フロー基盤の構築（4週間）

**目的**: 情報の構造化と検証の仕組みを整備

**タスク**:
- JSONドキュメント形式の標準化
- JSON Schema定義
- JSON-RPCインターフェース設計
- JSON Logicによるルール表現

**成功指標**:
- 全プロジェクト要件がJSON形式で文書化されている
- JSON Schemaによるバリデーションが自動化されている
- 基本的なJSON-RPCインターフェースが実装されている

### 8.3 フェーズ2: DDD的な役割分離の導入（3週間）

**目的**: ドメイン境界の明確化とユビキタス言語の確立

**タスク**:
- コンテキストマップ作成
- 各コンテキストのユビキタス言語定義
- コンテキスト間のインターフェース設計

**成功指標**:
- 境界付けられたコンテキストが明確に定義されている
- 各コンテキストにユビキタス言語が定義されている
- コンテキスト間の関係性が文書化されている

### 8.4 フェーズ3: TDD導入（3週間）

**目的**: テスト駆動開発プロセスの確立

**タスク**:
- テスト仕様のJSON形式標準化
- AIによるテスト生成フロー構築
- テスト自動化環境整備

**成功指標**:
- コード生成前にテストが作成される割合が90%以上
- テストカバレッジが80%以上
- テスト結果のフィードバックループが確立されている

### 8.5 フェーズ4: 設計原則とパターン適用（2週間）

**目的**: 設計原則とパターンの標準化

**タスク**:
- 設計原則の選定と文書化
- 設計パターンカタログ作成
- AIコード生成への適用方法確立

**成功指標**:
- 設計原則準拠度の自動評価が可能
- 設計パターンが実装に一貫して適用される
- 設計に関するフィードバックが迅速に反映される

### 8.6 フェーズ5: BDDとCI/CD連携（3週間）

**目的**: 振る舞い駆動開発とCI/CD連携の確立

**タスク**:
- BDD仕様のJSON形式標準化
- BDDからテスト自動生成フロー構築
- CI/CDパイプラインとの統合

**成功指標**:
- ビジネス要件がGherkin/JSONで表現され自動テストに変換される
- CI/CDパイプラインでの自動検証が実現している
- デプロイまでの自動化が完了している

## 9. まとめ

本ガイドラインは、AI駆動開発を統制された情報フローのもとで効率的に実施するための包括的な指針です。ブートストラップ問題に対応するため、フェーズ0からの段階的な導入を推奨し、各フェーズでの基盤の発展性を重視しています。

ミニマルな基盤から始め、徐々に高度な実装へと発展させることで、「すべてをまずは機械向けに正しく構造化し、必要に応じて人間向けに変換する」という基本理念を実現し、AI駆動開発の効率と品質を最大化することができます。

プロジェクトの規模や特性に応じて、各フェーズの優先度や実装詳細を適宜調整しながら、継続的に改善していくアプローチを推奨します。