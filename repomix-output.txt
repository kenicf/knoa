This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-20T11:01:58.797Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
ai-dev-guideline.md
docs/phases/phase0.md
docs/project-templates/frontend-template/ai-context/project-metadata.json
docs/project-templates/frontend-template/README.md
docs/project-templates/vba-template/ai-context/project-metadata.json
docs/project-templates/vba-template/README.md
docs/session-management.md
docs/task-management.md
README.md
src/schemas/feedback.schema.json
src/schemas/session.schema.json
src/schemas/task.schema.json
src/templates/docs/feedback.json
src/templates/docs/session-handover-template.md
src/templates/docs/session.json
src/templates/docs/task.json
src/templates/frontend/css/main.css
src/templates/frontend/html/index.html
src/templates/frontend/js/main.js
src/templates/vba/Main.bas
src/utils/session-manager.js
src/utils/task-manager.js

================================================================
Files
================================================================

================
File: ai-dev-guideline.md
================
# AI駆動開発のための包括的ガイドライン

## 1. 目的と基本理念

本ガイドラインは、AI駆動開発を統制された情報フローの下で効率的に実施するための指針です。「すべてをまずは機械向けに正しく構造化し、必要に応じて人間向けに変換する」という基本理念に基づき、プロジェクト全体の一貫性と品質を確保します。

### 1.1 ブートストラップ問題への対応

AI駆動開発のガイドラインを導入する際に「ガイドライン自体の導入にもAIを活用したい」という循環的な状況が発生します。この「ブートストラップ問題」を解決するため、本ガイドラインでは段階的アプローチを採用し、最小限の基盤（フェーズ0）から始めて徐々に完全な実装へと発展させることを推奨します。

## 2. 導入フェーズの全体像

プロジェクトへのAI駆動開発導入は、以下のフェーズで段階的に行います：

```
フェーズ0（2週間）→ フェーズ1（4週間）→ フェーズ2（3週間）→ フェーズ3（3週間）→ フェーズ4（2週間）→ フェーズ5（3週間）
```

各フェーズの概要：
- **フェーズ0**: ミニマルAI駆動開発基盤の構築（ブートストラップ）
- **フェーズ1**: 情報フロー基盤の構築
- **フェーズ2**: DDD的な役割分離の導入
- **フェーズ3**: TDD（テスト駆動開発）の組み込み
- **フェーズ4**: 設計原則・手法のルール化
- **フェーズ5**: BDDとCI/CD連携の確立

## 3. フェーズ0：ミニマルAI駆動開発基盤の構築

### 3.1 目的と位置づけ

フェーズ0は、本格的なガイドライン導入前に最小限の仕組みを構築し、その後のフェーズをAI駆動で効率的に実装するための基盤となります。複雑なフレームワークやツールは使わず、シンプルなアプローチで迅速に導入できることを重視します。

### 3.2 コアコンポーネント

#### 3.2.1 タスク分解・追跡システム

**目的**: ユーザーからの大きな指示を、AIが処理可能な粒度のタスクに分解し追跡する仕組み

**ミニマル実装**:
```json
{
  "project": "ユーザー管理システム開発",
  "original_request": "ユーザー登録機能とプロフィール編集機能を実装してください",
  "decomposed_tasks": [
    {
      "id": "T001",
      "title": "ユーザーエンティティ設計",
      "description": "ユーザーの属性とメソッドを定義",
      "status": "completed",
      "dependencies": []
    },
    {
      "id": "T002",
      "title": "ユーザー登録API実装",
      "description": "新規ユーザー登録エンドポイントの作成",
      "status": "in_progress",
      "dependencies": ["T001"]
    },
    {
      "id": "T003",
      "title": "プロフィール編集API実装",
      "description": "既存ユーザー情報更新エンドポイントの作成",
      "status": "pending",
      "dependencies": ["T001"]
    }
  ],
  "current_focus": "T002"
}
```

**発展性**: フェーズ1でJSONスキーマによる検証を追加し、フェーズ2でDDDコンテキストに基づくタスク分類を導入、フェーズ5でCI/CDと連携させた自動タスク追跡へ発展。

#### 3.2.2 セッション間状態保持

**目的**: 複数のAI対話セッションをまたいで開発コンテキストを維持する仕組み

**ミニマル実装**:
```json
{
  "session_handover": {
    "project_id": "USER-SYS-2025",
    "session_timestamp": "2025-03-20T15:30:00Z",
    "project_state_summary": {
      "completed_tasks": ["T001"],
      "current_tasks": ["T002"],
      "pending_tasks": ["T003", "T004"]
    },
    "key_artifacts": {
      "User.ts": "User entity with email and password fields",
      "UserRepository.ts": "Interface for user persistence",
      "auth.ts": "Authentication utilities"
    },
    "current_challenges": [
      "Email validation needs improvement",
      "Password hashing implementation pending"
    ],
    "next_session_focus": "Complete T002 and begin T003"
  }
}
```

**発展性**: フェーズ1でより詳細な構造定義を追加、フェーズ3でテスト結果の継続的な引継ぎを含める、フェーズ5でバージョン管理システムと連携した状態管理へと発展。

#### 3.2.3 シンプルなフィードバックループ

**目的**: 実装結果の検証とそのフィードバックを開発フローに反映する基本的な仕組み

**ミニマル実装**:
```json
{
  "feedback_loop": {
    "task_id": "T002",
    "implementation_attempt": 1,
    "verification_results": {
      "passes_tests": false,
      "failed_tests": [
        {
          "test_name": "should_reject_invalid_email",
          "error": "Expected validation error but got success"
        }
      ],
      "suggestions": [
        "Add regex validation for email format",
        "Implement proper error handling for invalid inputs"
      ]
    },
    "iteration_plan": {
      "focus_areas": ["Email validation logic", "Error response formatting"],
      "approach": "Refactor validation method with regex pattern"
    }
  }
}
```

**発展性**: フェーズ3でTDDフローへの組み込み、フェーズ4で設計パターンとの整合性検証の追加、フェーズ5で自動テスト実行とフィードバック生成の仕組みへ発展。

#### 3.2.4 最小限の標準化テンプレート

**目的**: 基本的なコード構造とドキュメント形式を標準化し、一貫性を確保

**ミニマル実装**: 基本的なコードテンプレート例
```typescript
// エンティティテンプレート
export class Entity {
  constructor(private readonly id: string) {}
  
  public getId(): string {
    return this.id;
  }
}

// リポジトリインターフェーステンプレート
export interface Repository<T> {
  findById(id: string): Promise<T | null>;
  save(entity: T): Promise<void>;
  delete(id: string): Promise<void>;
}

// テストテンプレート
describe('Entity', () => {
  it('should create entity with valid id', () => {
    // テスト実装
  });
});
```

**発展性**: フェーズ1でJSONテンプレートの体系化、フェーズ2でDDDパターンの標準テンプレート追加、フェーズ4で高度な設計パターンをテンプレート化、フェーズ5でBDDシナリオテンプレートを統合。

### 3.3 フェーズ0実装ガイド

1. **環境準備**: シンプルなGitリポジトリを用意し、基本的なディレクトリ構造を作成
2. **テンプレート作成**: 最小限のコードテンプレートとドキュメントテンプレートを定義
3. **タスク管理**: タスク分解と追跡のためのJSONファイル形式を定義
4. **状態管理**: セッション間の状態引継ぎフォーマットを定義
5. **フィードバック**: シンプルなテスト実行と結果フィードバックの流れを確立

### 3.4 成功指標

- ユーザー指示を5分以内に実行可能なタスクに分解できる
- セッションを跨いでも開発コンテキストを90%以上維持できる
- テスト結果から自動的に修正方針を導出できる
- 基本的なコード生成が一貫した構造で行える

## 4. ステップバイステップ実装ガイド（フェーズ1-5）

### 4.1 フェーズ1: 情報フローの設計と実装

#### 4.1.1 フェーズ0からの発展

フェーズ0で構築したミニマル基盤を以下のように拡張します：

- **タスク分解・追跡**: JSONスキーマによる厳密な構造定義を追加
- **セッション間状態**: より詳細な構造化と検証メカニズムを導入
- **標準化テンプレート**: 包括的なJSONテンプレートライブラリに発展

#### 4.1.2 プロジェクトドキュメントのJSON化

**実装内容：**
- プロジェクト要件、非機能要件、ビジネス背景、ステークホルダー情報を包括的にJSON形式で文書化
- すべての仕様と制約を階層的に構造化

**具体的な手順：**
1. プロジェクト基本情報を定義するJSONテンプレートを作成
```json
{
  "project_name": "AI駆動開発プロジェクト",
  "version": "1.0.0",
  "last_updated": "2025-03-16",
  "business_context": {
    "overview": "...",
    "goals": ["...", "..."],
    "success_criteria": ["...", "..."]
  },
  "stakeholders": [
    {
      "role": "プロダクトオーナー",
      "responsibilities": ["要件定義", "優先順位付け"]
    },
    ...
  ],
  "non_functional_requirements": {
    "performance": {...},
    "security": {...},
    "scalability": {...}
  }
}
```

2. 機能要件をコンテキスト別にJSONファイルとして分割
3. バージョン管理システムにドキュメントを登録（ファイル命名規則：`<context>_requirements.json`）

#### 4.1.3 JSON Schemaによる構造・制約の定義

**実装内容：**
- すべてのJSONドキュメントに対応するJSON Schemaを作成
- 型チェック、必須項目、値の範囲などを定義

**具体的な手順：**
1. 各JSONドキュメントに対するスキーマファイルを作成（ファイル命名規則：`<document_name>.schema.json`）
2. 以下の要素を必ず含める：
   - 型定義（string, number, object, array など）
   - 必須プロパティ（required配列）
   - プロパティの制約（minLength, maxLength, pattern など）
   - 列挙型の場合は必ず許容値を明示（enum）

#### 4.1.4 JSON-RPCによるAIとのインターフェース定義

**実装内容：**
- AIへの指示（タスク実行リクエスト）をJSON-RPC 2.0形式で標準化
- よく使われるメソッドのカタログ化

**具体的な手順：**
1. プロジェクトで使用するJSON-RPCメソッドの一覧を定義
2. 各メソッドのパラメータ仕様をJSON Schemaで定義
3. レスポンス形式の標準化

#### 4.1.5 JSON Logicによる複雑なビジネスルールの定義

**実装内容：**
- 条件分岐を含む複雑なビジネスルールをJSON Logic形式で表現
- AIによる正確な解釈のための標準化

### 4.2 フェーズ2: DDD的な役割分離の組み込み

#### 4.2.1 フェーズ0・1からの発展

フェーズ0・1の基盤を以下のように発展させます：

- **タスク分解・追跡**: ドメインコンテキストに基づく分類を追加
- **セッション間状態**: ドメインモデルの状態管理を強化
- **標準化テンプレート**: DDDパターンに基づくテンプレートを追加

#### 4.2.2 境界付けられたコンテキストの定義

**実装内容：**
- プロジェクトの業務領域を「境界付けられたコンテキスト」として分割
- コンテキスト間の関係性を明示

**具体的な手順：**
1. コンテキストマップの作成
```json
{
  "contexts": [
    {
      "name": "ユーザー管理",
      "responsibility": "ユーザー登録、認証、権限管理",
      "ubiquitous_language": {
        "User": "システムにアクセスする個人または組織",
        "Role": "特定の権限セット",
        "Permission": "特定の操作を実行する能力"
      }
    },
    {
      "name": "コンテンツ管理",
      "responsibility": "記事、メディア、タグの管理",
      ...
    },
    ...
  ],
  "context_relationships": [
    {
      "source": "ユーザー管理",
      "target": "コンテンツ管理",
      "type": "UPSTREAM_DOWNSTREAM",
      "anti_corruption_layer": true
    },
    ...
  ]
}
```

#### 4.2.3 ユビキタス言語の定義と管理

**実装内容：**
- 各コンテキストの専門用語を定義
- JSONによる用語集の管理

### 4.3 フェーズ3: TDD（テスト駆動開発）の組み込み

#### 4.3.1 フェーズ0-2からの発展

フェーズ0-2の基盤を以下のように発展させます：

- **シンプルなフィードバックループ**: 本格的なTDDサイクルへ拡張
- **標準化テンプレート**: テスト優先のテンプレートに発展
- **セッション間状態**: テスト結果の継続的な追跡と引継ぎ

#### 4.3.2 テストファースト開発の仕組み化

**実装内容：**
- AIコード生成前のテストケース作成フローを確立
- テスト仕様のJSON形式での標準化

**具体的な手順：**
1. テスト仕様のJSON Schemaを定義
2. テスト生成用のJSON-RPCメソッドを定義
3. テスト生成→テスト確認→コード生成の順序を強制するワークフロー構築

#### 4.3.3 テスト自動化と継続的検証

**実装内容：**
- AIが生成したテストの自動実行環境の構築
- テストカバレッジ計測と品質指標の設定

### 4.4 フェーズ4: 設計原則・手法のルール化

#### 4.4.1 フェーズ0-3からの発展

フェーズ0-3の基盤を以下のように発展させます：

- **最小限の標準化テンプレート**: 高度な設計パターンを組み込んだテンプレートへ発展
- **タスク分解・追跡**: 設計原則に基づく評価基準を追加
- **フィードバックループ**: 設計品質の評価を組み込み

#### 4.4.2 採用する設計原則の明確化

**実装内容：**
- プロジェクトで採用する設計原則の定義
- AIコード生成時に適用すべき原則の標準化

#### 4.4.3 設計パターンの標準化

**実装内容：**
- プロジェクトで使用する設計パターンのカタログ作成
- パターン適用時の命名規則・実装規約の定義

### 4.5 フェーズ5: CI/CDやBDDの開発プロセス組み込み

#### 4.5.1 フェーズ0-4からの発展

フェーズ0-4の基盤を以下のように発展させます：

- **タスク分解・追跡**: CI/CDパイプラインと連携した自動化
- **セッション間状態**: バージョン管理システムと連携した状態管理
- **フィードバックループ**: 自動テスト実行とフィードバック生成
- **標準化テンプレート**: BDDシナリオテンプレートの統合

#### 4.5.2 継続的インテグレーション/デリバリーの構築

**実装内容：**
- AIと連携した自動化CI/CDパイプラインの設計
- バリデーション、テスト、デプロイの自動化

#### 4.5.3 振る舞い駆動開発（BDD）の導入

**実装内容：**
- ビジネスシナリオの構造化記述と自動テスト連携
- AI駆動で振る舞い仕様から実装へのフロー確立

## 5. プランニングフローの実装

プランニングフローは、アーキテクチャ図に基づいて以下のコンポーネントで構成します：

### 5.1 コンポーネント構成

```json
{
  "components": {
    "User": {
      "responsibility": "開発指示や要件の入力、結果の確認を行う人間のユーザー",
      "interfaces": ["execute"]
    },
    "PlanningFlow": {
      "responsibility": "全体のワークフローを管理し、ステップの進行を制御",
      "interfaces": ["execute", "createPlan", "processPlanCompletion"]
    },
    "PlanningTool": {
      "responsibility": "タスクの分解、ステップの生成、進捗管理を担当",
      "interfaces": ["createPlan", "getPlanInfo", "markStepComplete"]
    },
    "Executor": {
      "responsibility": "実際のタスク実行を担当し、LLMとの通信を行う",
      "interfaces": ["executeStep", "processResult"]
    },
    "LLM": {
      "responsibility": "AI処理の実行（コード生成、レビュー、ドキュメント生成等）",
      "interfaces": ["executeTask"]
    }
  }
}
```

### 5.2 情報フロー詳細定義

各フェーズで整備された情報フローを、プランニングフローのコンポーネント間連携に適用します。

## 6. 具体的な実装テンプレート

### 6.1 JSON-RPC リクエスト例（コード生成）

```json
{
  "jsonrpc": "2.0",
  "method": "generate_code",
  "params": {
    "context": "ユーザー管理",
    "entity": "User",
    "requirements": {
      "attributes": [
        {"name": "id", "type": "string", "required": true},
        {"name": "email", "type": "string", "required": true, "validation": "email"},
        {"name": "name", "type": "string", "required": true},
        {"name": "password", "type": "string", "required": true, "minLength": 8}
      ],
      "behaviors": [
        {"name": "register", "description": "新規ユーザー登録処理"},
        {"name": "authenticate", "description": "認証処理"},
        {"name": "updateProfile", "description": "プロフィール更新処理"}
      ],
      "constraints": [
        "メールアドレスはユニークであること",
        "パスワードは8文字以上で、英数字と特殊文字を含むこと"
      ]
    },
    "design_principles": ["SRP", "OCP"],
    "patterns": ["repository", "factory"],
    "output_language": "typescript",
    "architecture": "hexagonal"
  },
  "id": 1
}
```

### 6.2 JSON-RPC レスポンス例

レスポンス例略（前回提示した内容に相当）

## 7. プロジェクト管理と品質監視

### 7.1 メトリクス収集と分析

AI駆動開発の効果を測定するために、以下のメトリクスを収集・分析します：

```json
{
  "metrics": {
    "development_velocity": {
      "story_points_per_iteration": {"target": 20, "min_acceptable": 15},
      "code_generation_to_production_time": {"target": "2 days", "max_acceptable": "5 days"}
    },
    "quality": {
      "defect_rate": {"target": "< 0.5 per 1000 LOC", "max_acceptable": "2 per 1000 LOC"},
      "test_coverage": {"target": "> 90%", "min_acceptable": "80%"},
      "ai_code_acceptance_rate": {"target": "> 80%", "min_acceptable": "60%"}
    },
    "ai_effectiveness": {
      "prompt_iteration_count": {"target": "< 2", "max_acceptable": 4},
      "human_modification_ratio": {"target": "< 20%", "max_acceptable": "40%"}
    }
  }
}
```

### 7.2 フィードバックループの確立

各フェーズにおけるフィードバックループの発展を踏まえ、最終的な形態を実現します。

## 8. 段階的導入ロードマップ（更新版）

### 8.1 フェーズ0: ミニマルAI駆動開発基盤の構築（2週間）

**目的**: ブートストラップ問題を解決し、後続フェーズの実装基盤を整備

**タスク**:
- タスク分解・追跡システムの最小実装
- セッション間状態保持の仕組み構築
- シンプルなフィードバックループ確立
- 最小限の標準化テンプレート整備

**成功指標**:
- ユーザー指示を5分以内に実行可能なタスクに分解できる
- セッションを跨いで開発コンテキストを90%以上維持できる
- テスト結果から自動的に修正方針を導出できる
- 基本的なコード生成が一貫した構造で行える

### 8.2 フェーズ1: 情報フロー基盤の構築（4週間）

**目的**: 情報の構造化と検証の仕組みを整備

**タスク**:
- JSONドキュメント形式の標準化
- JSON Schema定義
- JSON-RPCインターフェース設計
- JSON Logicによるルール表現

**成功指標**:
- 全プロジェクト要件がJSON形式で文書化されている
- JSON Schemaによるバリデーションが自動化されている
- 基本的なJSON-RPCインターフェースが実装されている

### 8.3 フェーズ2: DDD的な役割分離の導入（3週間）

**目的**: ドメイン境界の明確化とユビキタス言語の確立

**タスク**:
- コンテキストマップ作成
- 各コンテキストのユビキタス言語定義
- コンテキスト間のインターフェース設計

**成功指標**:
- 境界付けられたコンテキストが明確に定義されている
- 各コンテキストにユビキタス言語が定義されている
- コンテキスト間の関係性が文書化されている

### 8.4 フェーズ3: TDD導入（3週間）

**目的**: テスト駆動開発プロセスの確立

**タスク**:
- テスト仕様のJSON形式標準化
- AIによるテスト生成フロー構築
- テスト自動化環境整備

**成功指標**:
- コード生成前にテストが作成される割合が90%以上
- テストカバレッジが80%以上
- テスト結果のフィードバックループが確立されている

### 8.5 フェーズ4: 設計原則とパターン適用（2週間）

**目的**: 設計原則とパターンの標準化

**タスク**:
- 設計原則の選定と文書化
- 設計パターンカタログ作成
- AIコード生成への適用方法確立

**成功指標**:
- 設計原則準拠度の自動評価が可能
- 設計パターンが実装に一貫して適用される
- 設計に関するフィードバックが迅速に反映される

### 8.6 フェーズ5: BDDとCI/CD連携（3週間）

**目的**: 振る舞い駆動開発とCI/CD連携の確立

**タスク**:
- BDD仕様のJSON形式標準化
- BDDからテスト自動生成フロー構築
- CI/CDパイプラインとの統合

**成功指標**:
- ビジネス要件がGherkin/JSONで表現され自動テストに変換される
- CI/CDパイプラインでの自動検証が実現している
- デプロイまでの自動化が完了している

## 9. まとめ

本ガイドラインは、AI駆動開発を統制された情報フローのもとで効率的に実施するための包括的な指針です。ブートストラップ問題に対応するため、フェーズ0からの段階的な導入を推奨し、各フェーズでの基盤の発展性を重視しています。

ミニマルな基盤から始め、徐々に高度な実装へと発展させることで、「すべてをまずは機械向けに正しく構造化し、必要に応じて人間向けに変換する」という基本理念を実現し、AI駆動開発の効率と品質を最大化することができます。

プロジェクトの規模や特性に応じて、各フェーズの優先度や実装詳細を適宜調整しながら、継続的に改善していくアプローチを推奨します。

================
File: docs/phases/phase0.md
================
# フェーズ0: ミニマルAI駆動開発基盤の構築

## 目的と位置づけ

フェーズ0は、本格的なガイドライン導入前に最小限の仕組みを構築し、その後のフェーズをAI駆動で効率的に実装するための基盤となります。複雑なフレームワークやツールは使わず、シンプルなアプローチで迅速に導入できることを重視します。

## 実装内容

### 1. 環境準備

#### 1.1 リポジトリ構造

knoaリポジトリは以下の基本構造を持ちます：

```
knoa/
├── core/                # AI駆動開発の共通コアコンポーネント
├── projects/            # 個別プロジェクトディレクトリ（サブモジュール）
└── docs/                # プロジェクト全体のドキュメント
```

#### 1.2 サブモジュール管理

各プロジェクトは独立したGitリポジトリとして管理し、knoaからはサブモジュールとして参照します。

```
[submodule "projects/project-a"]
	path = projects/project-a
	url = https://github.com/your-org/project-a.git
	branch = main
```

#### 1.3 プロジェクトテンプレート

新規プロジェクト用のテンプレートを用意しています：

- フロントエンドプロジェクトテンプレート（HTML/CSS/JavaScript）
- VBAプロジェクトテンプレート

### 2. コアコンポーネント

#### 2.1 タスク分解・追跡システム

ユーザーからの大きな指示を、AIが処理可能な粒度のタスクに分解し追跡する仕組みです。

**実装**:
- タスク定義テンプレート: `core/templates/docs/task.json`
- タスク定義スキーマ: `core/schemas/task.schema.json`

#### 2.2 セッション間状態保持

複数のAI対話セッションをまたいで開発コンテキストを維持する仕組みです。

**実装**:
- セッション状態テンプレート: `core/templates/docs/session.json`
- セッション状態スキーマ: `core/schemas/session.schema.json`

#### 2.3 シンプルなフィードバックループ

実装結果の検証とそのフィードバックを開発フローに反映する基本的な仕組みです。

**実装**:
- フィードバックテンプレート: `core/templates/docs/feedback.json`
- フィードバックスキーマ: `core/schemas/feedback.schema.json`

#### 2.4 最小限の標準化テンプレート

基本的なコード構造とドキュメント形式を標準化し、一貫性を確保します。

**実装**:
- フロントエンドテンプレート:
  - HTML: `core/templates/frontend/html/index.html`
  - CSS: `core/templates/frontend/css/main.css`
  - JavaScript: `core/templates/frontend/js/main.js`
- VBAテンプレート:
  - `core/templates/vba/Main.bas`

### 3. 情報の凝集性を高める工夫

#### 3.1 メタデータの活用

各ファイルの先頭に構造化されたコメントブロックを追加し、AIが理解しやすい形でメタ情報を提供します。

```html
<!--
@ai-metadata {
  "purpose": "メインページ",
  "dependencies": ["styles/main.css", "scripts/main.js"],
  "lastModified": "2025-03-20"
}
-->
```

#### 3.2 AI用コンテキスト情報の集約

各プロジェクト内に「ai-context」ディレクトリを設け、AIが参照・更新する情報を集約します。

```
ai-context/
├── project-metadata.json       # プロジェクトの基本情報
├── tasks/                      # タスク情報
├── sessions/                   # セッション情報
└── feedback/                   # フィードバック情報
```

## 使用方法

### 1. 新規プロジェクトの作成

1. `docs/project-templates`から適切なテンプレートを選択
2. プロジェクト用のリポジトリを作成し、テンプレートをコピー
3. knoaリポジトリにサブモジュールとして追加

### 2. タスク管理

1. ユーザーからの指示を受け取ったら、`ai-context/tasks/current-tasks.json`にタスクを分解して記録
2. タスクの状態を更新しながら開発を進行

### 3. セッション管理

1. セッション終了時に`ai-context/sessions/latest-session.json`に状態を保存
2. 次のセッション開始時に前回の状態を読み込み

### 4. フィードバック管理

1. 実装結果の検証後、`ai-context/feedback/pending-feedback.json`にフィードバックを記録
2. フィードバックに基づいて改善を実施

## 成功指標

- ユーザー指示を5分以内に実行可能なタスクに分解できる
- セッションを跨いでも開発コンテキストを90%以上維持できる
- テスト結果から自動的に修正方針を導出できる
- 基本的なコード生成が一貫した構造で行える

## 次のステップ

フェーズ0の基盤を活用して、フェーズ1「情報フロー基盤の構築」へと進みます。フェーズ1では以下を実装します：

- JSONドキュメント形式の標準化
- JSON Schema定義の拡充
- JSON-RPCインターフェース設計
- JSON Logicによるルール表現

================
File: docs/project-templates/frontend-template/ai-context/project-metadata.json
================
{
  "project_name": "フロントエンドプロジェクトテンプレート",
  "project_type": "frontend",
  "version": "1.0.0",
  "created_at": "2025-03-20T11:30:00Z",
  "last_updated": "2025-03-20T11:30:00Z",
  "description": "AI駆動開発のためのフロントエンドプロジェクト（HTML/CSS/JavaScript）の基本構造",
  "technologies": [
    "HTML5",
    "CSS3",
    "JavaScript"
  ],
  "structure": {
    "src": {
      "purpose": "ソースコード",
      "key_files": [
        {"path": "index.html", "purpose": "メインページ"},
        {"path": "styles/main.css", "purpose": "メインスタイル"},
        {"path": "scripts/main.js", "purpose": "メイン機能"}
      ]
    },
    "ai-context": {
      "purpose": "AI用コンテキスト情報",
      "key_files": [
        {"path": "project-metadata.json", "purpose": "プロジェクト情報"},
        {"path": "tasks/current-tasks.json", "purpose": "現在のタスク"}
      ]
    }
  },
  "domain_concepts": [],
  "development_flow": {
    "current_phase": "初期化",
    "next_steps": ["要件定義", "設計", "実装"]
  }
}

================
File: docs/project-templates/frontend-template/README.md
================
# フロントエンドプロジェクトテンプレート

## 概要
このテンプレートは、AI駆動開発のためのフロントエンドプロジェクト（HTML/CSS/JavaScript）の基本構造を提供します。

## 使い方

### 1. 新規リポジトリの作成
GitHub等で新しいリポジトリを作成します。

### 2. テンプレートのクローンと初期化
```bash
# テンプレートをクローン
git clone https://github.com/your-org/frontend-template.git new-project
cd new-project

# リモートの変更
git remote remove origin
git remote add origin https://github.com/your-org/new-project.git

# 初期コミットとプッシュ
git add .
git commit -m "Initial commit from template"
git push -u origin main
```

### 3. knoaリポジトリへのサブモジュール追加
```bash
cd /path/to/knoa
git submodule add https://github.com/your-org/new-project.git projects/new-project
git commit -m "Add new-project as submodule"
git push
```

## ディレクトリ構造
```
frontend-template/
├── README.md                # このファイル
├── .gitignore               # Git除外設定
├── ai-context/              # AI用コンテキスト情報
│   ├── project-metadata.json  # プロジェクトメタデータ
│   ├── tasks/               # タスク情報
│   ├── sessions/            # セッション情報
│   └── feedback/            # フィードバック情報
└── src/                     # ソースコード
    ├── index.html           # メインHTML
    ├── styles/              # CSSファイル
    │   └── main.css         # メインCSS
    ├── scripts/             # JavaScriptファイル
    │   └── main.js          # メインJS
    └── assets/              # 静的アセット
        ├── images/          # 画像ファイル
        └── fonts/           # フォントファイル
```

## AI駆動開発のポイント

### メタデータの活用
各ファイルの先頭には`@ai-metadata`コメントブロックを配置し、AIが理解しやすい形でメタ情報を提供しています。

```html
<!--
@ai-metadata {
  "purpose": "メインページ",
  "dependencies": ["styles/main.css", "scripts/main.js"],
  "lastModified": "2025-03-20"
}
-->
```

### AI用コンテキスト情報
`ai-context`ディレクトリには、AIが参照・更新する情報を集約しています。タスク、セッション、フィードバックの情報を構造化して管理します。

## カスタマイズ方法
1. `project-metadata.json`のプロジェクト情報を更新
2. `index.html`のタイトルとコンテンツを変更
3. `main.css`のスタイルをプロジェクトに合わせて調整
4. `main.js`の機能を実装

## ライセンス
OSSとして公開（ライセンスを指定）

================
File: docs/project-templates/vba-template/ai-context/project-metadata.json
================
{
  "project_name": "VBAプロジェクトテンプレート",
  "project_type": "vba",
  "version": "1.0.0",
  "created_at": "2025-03-20T11:30:00Z",
  "last_updated": "2025-03-20T11:30:00Z",
  "description": "AI駆動開発のためのVBAプロジェクトの基本構造",
  "technologies": [
    "VBA",
    "Excel",
    "Access"
  ],
  "structure": {
    "src": {
      "purpose": "ソースコード",
      "key_files": [
        {"path": "modules/Main.bas", "purpose": "メインモジュール"},
        {"path": "modules/Utilities.bas", "purpose": "ユーティリティモジュール"},
        {"path": "forms/UserForm1.frm", "purpose": "サンプルフォーム"},
        {"path": "class-modules/DataProcessor.cls", "purpose": "データ処理クラス"}
      ]
    },
    "ai-context": {
      "purpose": "AI用コンテキスト情報",
      "key_files": [
        {"path": "project-metadata.json", "purpose": "プロジェクト情報"},
        {"path": "tasks/current-tasks.json", "purpose": "現在のタスク"}
      ]
    }
  },
  "domain_concepts": [],
  "development_flow": {
    "current_phase": "初期化",
    "next_steps": ["要件定義", "設計", "実装"]
  }
}

================
File: docs/project-templates/vba-template/README.md
================
# VBAプロジェクトテンプレート

## 概要
このテンプレートは、AI駆動開発のためのVBAプロジェクトの基本構造を提供します。Excel、Access、Wordなどで使用するVBAモジュールの開発に適しています。

## 使い方

### 1. 新規リポジトリの作成
GitHub等で新しいリポジトリを作成します。

### 2. テンプレートのクローンと初期化
```bash
# テンプレートをクローン
git clone https://github.com/your-org/vba-template.git new-vba-project
cd new-vba-project

# リモートの変更
git remote remove origin
git remote add origin https://github.com/your-org/new-vba-project.git

# 初期コミットとプッシュ
git add .
git commit -m "Initial commit from template"
git push -u origin main
```

### 3. knoaリポジトリへのサブモジュール追加
```bash
cd /path/to/knoa
git submodule add https://github.com/your-org/new-vba-project.git projects/new-vba-project
git commit -m "Add new-vba-project as submodule"
git push
```

## ディレクトリ構造
```
vba-template/
├── README.md                # このファイル
├── .gitignore               # Git除外設定
├── ai-context/              # AI用コンテキスト情報
│   ├── project-metadata.json  # プロジェクトメタデータ
│   ├── tasks/               # タスク情報
│   ├── sessions/            # セッション情報
│   └── feedback/            # フィードバック情報
└── src/                     # ソースコード
    ├── modules/             # 標準モジュール
    │   ├── Main.bas         # メインモジュール
    │   └── Utilities.bas    # ユーティリティモジュール
    ├── forms/               # フォーム
    │   └── UserForm1.frm    # サンプルフォーム
    └── class-modules/       # クラスモジュール
        └── DataProcessor.cls # データ処理クラス
```

## AI駆動開発のポイント

### メタデータの活用
各モジュールの先頭には`@ai-metadata`コメントブロックを配置し、AIが理解しやすい形でメタ情報を提供しています。

```vba
' @ai-metadata {
'   "purpose": "メインモジュール",
'   "dependencies": ["Utilities.bas"],
'   "exports": ["Initialize", "Main"],
'   "lastModified": "2025-03-20"
' }
```

### AI用コンテキスト情報
`ai-context`ディレクトリには、AIが参照・更新する情報を集約しています。タスク、セッション、フィードバックの情報を構造化して管理します。

## VBAコードの管理

### エクスポート/インポート
VBAコードはバイナリ形式（.xlsm, .accdb等）で保存されるため、テキストベースのバージョン管理のために以下のアプローチを使用します：

1. VBAコードをテキストファイル（.bas, .cls, .frm）としてエクスポート
2. テキストファイルをバージョン管理
3. 必要に応じてVBAプロジェクトにインポート

### 推奨ツール
- [VBA-Toolbox](https://github.com/example/vba-toolbox)（仮想リンク）: VBAコードのエクスポート/インポートを自動化

## カスタマイズ方法
1. `project-metadata.json`のプロジェクト情報を更新
2. `Main.bas`の初期化処理とメイン処理を実装
3. 必要に応じてフォームとクラスモジュールを追加

## ライセンス
OSSとして公開（ライセンスを指定）

================
File: docs/session-management.md
================
# セッション管理システム

## 概要

セッション管理システムは、AI駆動開発における複数のセッションをまたいだ開発コンテキストの維持を実現するためのシステムです。セッションの状態、変更履歴、課題、アクションアイテムなどを構造化された形式で管理し、セッション間の連続性と追跡可能性を向上させます。

## 主な機能

- **セッション状態の管理**: セッションの開始・終了時刻、タスク状態、重要なファイルなどの管理
- **Git連携**: セッションとGitコミットの関連付け、変更差分の記録
- **課題とアクションアイテムの管理**: 優先度と重要度の2軸での評価、状態管理
- **マークダウン形式の引継ぎドキュメント生成**: カスタマイズ可能なテンプレートを使用

## セッションスキーマ

セッションは以下のスキーマに基づいて構造化されています：

```json
{
  "session_handover": {
    "project_id": "プロジェクトID",
    "session_id": "セッションID（Gitコミットハッシュ）",
    "previous_session_id": "前回のセッションID",
    "session_timestamp": "セッション終了時刻",
    "session_start_timestamp": "セッション開始時刻",
    "project_state_summary": {
      "completed_tasks": ["完了したタスクID"],
      "current_tasks": ["進行中のタスクID"],
      "pending_tasks": ["保留中のタスクID"],
      "blocked_tasks": ["ブロックされているタスクID"]
    },
    "key_artifacts": [
      {
        "path": "ファイルパス",
        "description": "ファイルの説明",
        "last_modified": "最終更新日時",
        "git_status": "Gitの状態",
        "previous_path": "リネーム前のパス",
        "related_tasks": ["関連するタスクID"],
        "importance": "重要度"
      }
    ],
    "git_changes": {
      "commits": [
        {
          "hash": "コミットハッシュ",
          "message": "コミットメッセージ",
          "timestamp": "コミット日時",
          "related_tasks": ["関連するタスクID"],
          "author": "コミット作者"
        }
      ],
      "summary": {
        "files_added": 0,
        "files_modified": 0,
        "files_deleted": 0,
        "lines_added": 0,
        "lines_deleted": 0
      }
    },
    "other_changes": {
      "config_changes": [
        {
          "config_type": "設定タイプ",
          "description": "変更の説明",
          "timestamp": "変更日時"
        }
      ],
      "external_changes": [
        {
          "system": "外部システム名",
          "change_type": "変更タイプ",
          "description": "変更の説明",
          "timestamp": "変更日時"
        }
      ]
    },
    "current_challenges": [
      {
        "description": "課題の説明",
        "related_tasks": ["関連するタスクID"],
        "priority": 3,
        "severity": 3,
        "status": "課題の状態",
        "resolution_plan": "解決計画"
      }
    ],
    "next_session_focus": "次のセッションでの焦点",
    "action_items": [
      {
        "description": "アクションの説明",
        "related_task": "関連するタスクID",
        "priority": 3,
        "severity": 3,
        "due_date": "期限",
        "assignee": "担当者"
      }
    ]
  }
}
```

## セッション管理ユーティリティ

セッション管理ユーティリティ（`SessionManager`）は、セッションの作成、取得、更新、保存などの機能を提供します。

### 主なメソッド

#### セッション基本操作

- **validateSession(session)**: セッションの検証
- **getLatestSession()**: 最新のセッションを取得
- **getSessionById(sessionId)**: セッションIDでセッションを取得
- **createNewSession(previousSessionId)**: 新しいセッションを作成
- **saveSession(session, isLatest)**: セッションを保存

#### Git連携

- **createSessionFromGitCommits(startCommit, endCommit)**: Gitコミットからセッション情報を生成
- **updateSessionWithGitChanges(sessionId, commits)**: セッションをGit変更で更新
- **extractTaskIdsFromCommitMessage(message)**: コミットメッセージからタスクIDを抽出
- **calculateChangeSummary(commits)**: 変更サマリーを計算

#### セッション内容管理

- **addKeyArtifact(sessionId, artifact)**: key_artifactを追加
- **addChallenge(sessionId, challenge)**: 課題を追加
- **addActionItem(sessionId, actionItem)**: アクションアイテムを追加
- **getKeyArtifactCandidates(commits)**: key_artifactの候補を取得
- **linkActionItemsToTasks(sessionId)**: アクションアイテムとタスクを関連付け

#### セッション分析

- **getSessionDiff(sessionId1, sessionId2)**: セッション間の差分を取得
- **generateSessionHandoverMarkdown(sessionId, templateName)**: マークダウン形式の引継ぎドキュメントを生成

## 使用例

### 新しいセッションの作成

```javascript
const { SessionManager } = require('../src/utils/session-manager');

// SessionManagerのインスタンスを作成
const sessionManager = new SessionManager();

// 新しいセッションを作成
const newSession = sessionManager.createNewSession();

// セッションを保存
sessionManager.saveSession(newSession, true);
```

### Gitコミットからセッション情報を生成

```javascript
// 開始コミットと終了コミットを指定してセッション情報を生成
const session = sessionManager.createSessionFromGitCommits('start-commit-hash', 'end-commit-hash');

// セッションを保存
sessionManager.saveSession(session, true);
```

### 課題の追加

```javascript
// 課題を追加
const updatedSession = sessionManager.addChallenge('session-id', {
  description: '新しい課題',
  related_tasks: ['T001'],
  priority: 4,
  severity: 3,
  status: 'in_progress',
  resolution_plan: '解決計画'
});

// 更新されたセッションを保存
sessionManager.saveSession(updatedSession, true);
```

### マークダウン形式の引継ぎドキュメントの生成

```javascript
// マークダウン形式の引継ぎドキュメントを生成
const markdown = sessionManager.generateSessionHandoverMarkdown('session-id');

// マークダウンをファイルに保存
const fs = require('fs');
fs.writeFileSync('session-handover.md', markdown, 'utf8');
```

## 優先度と重要度の2軸管理

課題とアクションアイテムは、優先度と重要度の2軸で評価されます：

### 優先度（Priority）

ビジネス価値や機能的重要性を表します：

- **1**: 最低優先度（あれば便利だが、なくても問題ない）
- **2**: 低優先度（将来的に必要だが、今すぐではない）
- **3**: 中優先度（標準的な優先度）
- **4**: 高優先度（重要な機能や改善）
- **5**: 最高優先度（ビジネスクリティカルな機能）

### 重要度（Severity）

技術的影響や緊急性を表します：

- **1**: 最低重要度（小さな問題、影響が限定的）
- **2**: 低重要度（軽微な問題、回避策がある）
- **3**: 中重要度（標準的な重要度）
- **4**: 高重要度（深刻な問題、大きな影響がある）
- **5**: 最高重要度（クリティカルな問題、即時対応が必要）

### 組み合わせの解釈

- **高優先度・高重要度**: 即時対応が必要
- **高優先度・低重要度**: 重要だが緊急ではない
- **低優先度・高重要度**: 技術的に重要だが、ビジネス価値は低い
- **低優先度・低重要度**: 後回しにできる

## 課題の状態

課題は以下の状態を持ちます：

- **identified**: 特定済み（課題が特定されたが、まだ分析されていない）
- **analyzing**: 分析中（課題の原因や影響を分析中）
- **in_progress**: 対応中（課題の解決に取り組んでいる）
- **resolved**: 解決済み（課題が解決された）
- **wontfix**: 対応しない（課題を解決しないことを決定）

## マークダウンテンプレート

マークダウン形式の引継ぎドキュメントは、テンプレートに基づいて生成されます。テンプレートは `src/templates/docs/session-handover-template.md` に定義されています。

テンプレートでは、以下のようなプレースホルダーを使用できます：

- **{{project_id}}**: プロジェクトID
- **{{session_timestamp}}**: セッションのタイムスタンプ
- **{{session_duration}}**: セッション時間
- **{{session_id}}**: セッションID
- **{{previous_session_id}}**: 前回のセッションID
- **{{completed_tasks_formatted}}**: フォーマットされた完了タスク
- **{{current_tasks_formatted}}**: フォーマットされた進行中タスク
- **{{pending_tasks_formatted}}**: フォーマットされた保留中タスク
- **{{blocked_tasks_formatted}}**: フォーマットされたブロック中タスク
- **{{implementation_summary}}**: 実装サマリー
- **{{key_changes}}**: 主な変更点
- **{{key_artifacts_formatted}}**: フォーマットされたkey_artifact
- **{{commit_count}}**: コミット数
- **{{files_added}}**: 追加ファイル数
- **{{files_modified}}**: 変更ファイル数
- **{{files_deleted}}**: 削除ファイル数
- **{{lines_added}}**: 追加行数
- **{{lines_deleted}}**: 削除行数
- **{{commits_formatted}}**: フォーマットされたコミット
- **{{other_changes_formatted}}**: フォーマットされたその他の変更
- **{{resolved_challenges}}**: 解決済みの課題
- **{{current_challenges_formatted}}**: フォーマットされた現在の課題
- **{{next_session_focus}}**: 次のセッションでの焦点
- **{{action_items_formatted}}**: フォーマットされたアクションアイテム
- **{{recommendations}}**: 推奨事項

## ベストプラクティス

### セッション管理

- **セッションの境界を明確に**: セッションの開始時と終了時に明示的にコミットを作成し、セッションの境界を明確にします。
- **定期的なセッション作成**: 長時間の作業では、定期的にセッションを作成して状態を保存します。
- **セッションIDの一貫性**: セッションIDとしてGitコミットハッシュを使用し、一貫性を確保します。

### Git連携

- **コミットメッセージの標準化**: コミットメッセージにタスクIDを含める形式を標準化します（例: `"機能実装 #T001"`）。
- **関連タスクの明示**: コミットメッセージに関連するタスクIDを明示的に記載します。
- **適切な粒度のコミット**: 適切な粒度でコミットを作成し、変更の追跡性を向上させます。

### 課題とアクションアイテム

- **優先度と重要度の適切な評価**: 課題とアクションアイテムの優先度と重要度を適切に評価します。
- **解決計画の明確化**: 課題の解決計画を明確に記載します。
- **期限の設定**: アクションアイテムには適切な期限を設定します。

### マークダウン生成

- **テンプレートのカスタマイズ**: プロジェクトの要件に合わせてマークダウンテンプレートをカスタマイズします。
- **重要な情報のハイライト**: 重要な情報を適切にハイライトします。
- **定期的なドキュメント生成**: 定期的にマークダウン形式の引継ぎドキュメントを生成し、共有します。

## トラブルシューティング

### セッションの検証エラー

セッションの検証エラーが発生した場合は、以下を確認してください：

- 必須フィールドが存在するか
- タスクIDの形式が正しいか（`T001`形式）
- 日時形式が正しいか（ISO 8601形式）

### Git連携の問題

Git連携に問題がある場合は、以下を確認してください：

- Gitリポジトリが正しく設定されているか
- 必要なGitコマンドが実行可能か
- コミットメッセージの形式が標準化されているか

### マークダウン生成の問題

マークダウン生成に問題がある場合は、以下を確認してください：

- テンプレートファイルが存在するか
- テンプレート内のプレースホルダーが正しいか
- セッション情報が正しく設定されているか

================
File: docs/task-management.md
================
# タスク管理システム詳細ドキュメント

## 概要

タスク管理システムは、AI駆動開発の中核となるコンポーネントで、ユーザーからの大きな指示をAIが処理可能な粒度のタスクに分解し、それらのタスクの進捗を追跡するための仕組みです。このドキュメントでは、タスク管理システムの詳細な仕様と使用方法について説明します。

## 1. タスク管理の基本構造

タスク管理システムは以下のコンポーネントで構成されています：

1. **タスク定義スキーマ**: `src/schemas/task.schema.json`
2. **タスクテンプレート**: `src/templates/docs/task.json`
3. **タスク管理ユーティリティ**: `src/utils/task-manager.js`
4. **タスク情報ストレージ**: `ai-context/tasks/current-tasks.json`

## 2. タスクスキーマ

タスクは以下の構造で定義されます：

```json
{
  "project": "プロジェクト名",
  "original_request": "ユーザーからの元の指示",
  "task_hierarchy": {
    "epics": [...],
    "stories": [...]
  },
  "decomposed_tasks": [
    {
      "id": "T001",
      "title": "タスクタイトル",
      "description": "タスクの詳細説明",
      "status": "pending|in_progress|completed|blocked",
      "dependencies": [
        {
          "task_id": "T002",
          "type": "strong|weak"
        }
      ],
      "priority": 1-5,
      "estimated_hours": 数値,
      "progress_percentage": 0-100,
      "progress_state": "not_started|planning|in_development|implementation_complete|in_review|review_complete|in_testing|completed",
      "git_commits": ["コミットハッシュ1", "コミットハッシュ2"]
    }
  ],
  "current_focus": "T001"
}
```

### 2.1 フィールドの説明

#### プロジェクト情報
- `project`: プロジェクト名
- `original_request`: ユーザーからの元の指示

#### 階層構造（将来的な拡張用）
- `task_hierarchy`: タスクの階層構造
  - `epics`: エピック（大きな機能単位）のリスト
  - `stories`: ストーリー（ユーザーストーリー）のリスト

#### タスク情報
- `decomposed_tasks`: 分解されたタスクのリスト
  - `id`: タスクID（T001形式）
  - `title`: タスクタイトル
  - `description`: タスクの詳細説明
  - `status`: タスクの状態
    - `pending`: 保留中
    - `in_progress`: 進行中
    - `completed`: 完了
    - `blocked`: ブロック中
  - `dependencies`: 依存するタスクのリスト
    - `task_id`: 依存するタスクのID
    - `type`: 依存タイプ
      - `strong`: 強い依存（タスク完了が必須）
      - `weak`: 弱い依存（参照のみ）
  - `priority`: 優先度（1:最低 〜 5:最高）
  - `estimated_hours`: 見積もり時間（時間単位）
  - `progress_percentage`: 進捗率（0-100%）
  - `progress_state`: 進捗状態
    - `not_started`: 未開始
    - `planning`: 計画中
    - `in_development`: 開発中
    - `implementation_complete`: 実装完了
    - `in_review`: レビュー中
    - `review_complete`: レビュー完了
    - `in_testing`: テスト中
    - `completed`: 完了
  - `git_commits`: 関連するGitコミットハッシュのリスト

#### 現在のフォーカス
- `current_focus`: 現在フォーカスしているタスクID

## 3. 進捗状態と進捗率

各進捗状態には、デフォルトの進捗率が設定されています：

| 進捗状態 | 説明 | デフォルト進捗率 |
|---------|------|--------------|
| not_started | タスクがまだ開始されていない状態 | 0% |
| planning | タスクの計画段階 | 10% |
| in_development | 開発中の状態 | 30% |
| implementation_complete | 実装が完了した状態 | 60% |
| in_review | レビュー中の状態 | 70% |
| review_complete | レビューが完了した状態 | 80% |
| in_testing | テスト中の状態 | 90% |
| completed | タスクが完了した状態 | 100% |

### 3.1 状態遷移

進捗状態は以下の遷移に従います：

```
not_started → planning → in_development → implementation_complete → in_review → review_complete → in_testing → completed
```

特殊な遷移：
- `in_development` → `in_review`（小規模タスク）
- `in_review` → `in_development`（レビュー指摘）
- `in_testing` → `in_development`（テスト不合格）

## 4. 依存関係の管理

タスク間の依存関係は2種類あります：

1. **強い依存（strong）**: 依存先のタスクが完了しないと、このタスクを開始できない
2. **弱い依存（weak）**: 依存先のタスクの情報を参照するが、完了を待たずに開始できる

依存関係の循環（A→B→C→A）は検出され、エラーとして報告されます。

## 5. Git連携

タスクとGitコミットを関連付けることで、変更履歴とタスク進捗の一元管理が可能になります。

### 5.1 コミットメッセージからのタスクID抽出

コミットメッセージに `#T001` 形式でタスクIDを含めることで、自動的にタスクとコミットが関連付けられます。

例：
```
git commit -m "ログイン機能の実装 #T001"
```

## 6. タスク管理ユーティリティ

`src/utils/task-manager.js` には、タスク管理に関する様々なユーティリティ関数が実装されています：

### 6.1 タスク検証

```javascript
const result = taskManager.validateTask(task);
if (result.isValid) {
  console.log("タスクは有効です");
} else {
  console.error("タスクエラー:", result.errors);
}
```

### 6.2 依存関係チェック

```javascript
const result = taskManager.checkDependencies(taskId, tasks);
if (result.isValid) {
  console.log("依存関係は正常です");
} else {
  console.error("依存関係エラー:", result.errors);
  console.warn("警告:", result.warnings);
}
```

### 6.3 進捗管理

```javascript
// 進捗率の計算
const progress = taskManager.calculateProgress(taskId, tasks);

// 進捗の更新
const result = taskManager.updateTaskProgress(taskId, percentage, state, tasks);
if (result.success) {
  console.log(result.message);
  // 更新されたタスクリストを保存
  saveTasks(result.updatedTasks);
}
```

### 6.4 タスクフィルタリング

```javascript
// ステータスでフィルタリング
const inProgressTasks = taskManager.getTasksByStatus(tasks, "in_progress");

// 進捗状態でフィルタリング
const inReviewTasks = taskManager.getTasksByProgressState(tasks, "in_review");

// Gitコミットでフィルタリング
const tasksWithCommit = taskManager.getTasksWithGitCommit(tasks, commitHash);
```

### 6.5 Git連携

```javascript
// コミットの関連付け
const result = taskManager.addGitCommitToTask(taskId, commitHash, tasks);

// コミットメッセージからタスクID抽出
const taskIds = taskManager.extractTaskIdsFromCommitMessage(commitMessage);
```

### 6.6 タスク移行

```javascript
// 古い形式から新しい形式への変換
const newTask = taskManager.migrateTaskToNewFormat(oldTask);
```

## 7. 使用例

### 7.1 タスクの作成

```javascript
const newTask = {
  id: "T010",
  title: "新機能の実装",
  description: "新機能の詳細説明",
  status: "pending",
  dependencies: [
    {
      task_id: "T009",
      type: "strong"
    }
  ],
  priority: 4,
  estimated_hours: 8,
  progress_percentage: 0,
  progress_state: "not_started",
  git_commits: []
};

// タスクの検証
const validationResult = taskManager.validateTask(newTask);
if (validationResult.isValid) {
  // タスクリストに追加
  tasks.decomposed_tasks.push(newTask);
  // 保存
  saveTasks(tasks);
}
```

### 7.2 タスクの進捗更新

```javascript
// タスクの進捗を更新
const result = taskManager.updateTaskProgress("T010", 30, "in_development", tasks);
if (result.success) {
  // 更新されたタスクリストを保存
  saveTasks(result.updatedTasks);
}
```

### 7.3 Gitコミットの関連付け

```javascript
// コミットメッセージからタスクIDを抽出
const commitMessage = "新機能の実装 #T010";
const taskIds = taskManager.extractTaskIdsFromCommitMessage(commitMessage);

// 各タスクにコミットを関連付け
for (const taskId of taskIds) {
  const result = taskManager.addGitCommitToTask(taskId, "abc123", tasks);
  if (result.success) {
    // 更新されたタスクリストを保存
    saveTasks(result.updatedTasks);
  }
}
```

## 8. ベストプラクティス

### 8.1 タスク分解

- タスクは1-4時間程度で完了できる粒度に分解する
- 依存関係は明確に定義し、循環依存を避ける
- 優先度は適切に設定し、重要なタスクを先に実施する

### 8.2 進捗管理

- 進捗状態は実際の作業状況を反映するよう定期的に更新する
- レビューやテストのフェーズも含めて進捗を管理する
- ブロッカーが発生した場合は、すぐにステータスを「blocked」に変更する

### 8.3 Git連携

- コミットメッセージには必ず関連するタスクIDを `#T001` 形式で含める
- 複数のタスクに関連する変更の場合は、すべてのタスクIDを記載する
- 大きな変更は複数の小さなコミットに分割し、各コミットを適切なタスクに関連付ける

## 9. 将来の拡張

タスク管理システムは、フェーズ1以降で以下の拡張が予定されています：

1. **JSONスキーマによる厳密な検証**: より詳細なバリデーションルールの追加
2. **階層構造の本格的な導入**: エピック、ストーリー、タスクの階層管理
3. **外部システムとの連携**: JIRAやGitHubなどの外部タスク管理システムとの連携
4. **自動化機能の強化**: 進捗の自動検出、依存関係の自動解決など

## 10. トラブルシューティング

### 10.1 よくある問題

1. **タスク検証エラー**
   - 必須フィールドが欠けていないか確認
   - IDの形式が正しいか確認（T001形式）
   - 依存関係が正しく定義されているか確認

2. **循環依存エラー**
   - 依存関係のグラフを確認し、循環を解消
   - 必要に応じて弱い依存に変更

3. **進捗状態の不整合**
   - 進捗状態と進捗率が一致しているか確認
   - 状態遷移のルールに従っているか確認

### 10.2 サポート

問題が解決しない場合は、以下の方法でサポートを受けることができます：

- GitHub Issueの作成
- プロジェクト管理者への連絡

================
File: README.md
================
# knoa - AI駆動開発プロジェクト

## 概要
knoaは、AI駆動開発を統制された情報フローの下で効率的に実施するためのプロジェクトです。「すべてをまずは機械向けに正しく構造化し、必要に応じて人間向けに変換する」という基本理念に基づいています。

## 構造
- `src/`: AI駆動開発の共通コアコンポーネント（旧core）
- `projects/`: 個別プロジェクトディレクトリ（サブモジュール）
- `docs/`: プロジェクト全体のドキュメント
- `ai-context/`: knoa自体のAI用コンテキスト情報

## 循環的開発構造
knoaは以下の二重の役割を持ちます：
1. AI駆動開発を実施するためのメタプロジェクト
2. AI駆動開発の対象となるプロジェクト自体

この循環的構造により、knoaを使ってknoa自体を開発するという自己適用的なアプローチが可能になります。`ai-context`ディレクトリには、knoa自体の開発に関するタスク、セッション、フィードバック情報が格納され、他のプロジェクトと同じスキーマを使用して管理されます。

## 導入フェーズ
1. **フェーズ0**: ミニマルAI駆動開発基盤の構築（ブートストラップ）
2. **フェーズ1**: 情報フロー基盤の構築
3. **フェーズ2**: DDD的な役割分離の導入
4. **フェーズ3**: TDD（テスト駆動開発）の組み込み
5. **フェーズ4**: 設計原則・手法のルール化
6. **フェーズ5**: BDDとCI/CD連携の確立

## 使い方

### 新規プロジェクトの開始
1. `docs/project-templates`から適切なテンプレートを選択
2. プロジェクト用のリポジトリを作成し、テンプレートをコピー
3. knoaリポジトリにサブモジュールとして追加

### knoa自体の開発
1. `ai-context/tasks/current-tasks.json`でknoaの開発タスクを管理
2. `ai-context/sessions/latest-session.json`でセッション状態を管理
3. `ai-context/feedback/pending-feedback.json`で改善点を管理
4. `session-handover.md`で最新のセッション引継ぎ情報を確認（フェーズ0の暫定的な対応）

## セッション間の引継ぎ

フェーズ0の段階では、セッション間の引継ぎは以下の方法で行います：

1. **セッション引継ぎドキュメント**:
   - `session-handover.md`には、最新のセッションで実施した内容、タスクの状態、次のセッションでの焦点などが記録されています
   - 新しいセッションを開始する際は、まずこのドキュメントを参照してください

2. **JSONファイルの更新**:
   - セッション引継ぎドキュメントの情報を基に、次のセッションで各JSONファイルを更新してください
   - これは、フェーズ0の暫定的な対応であり、フェーズ1で改善される予定です

フェーズ1「情報フロー基盤の構築」では、セッション間の引継ぎプロセスが改善され、より構造化された形で情報が管理されるようになります。

## ライセンス
プライベートリポジトリ - 無断複製・配布禁止

================
File: src/schemas/feedback.schema.json
================
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "required": ["feedback_loop"],
  "properties": {
    "feedback_loop": {
      "type": "object",
      "required": ["task_id", "implementation_attempt", "verification_results", "iteration_plan"],
      "properties": {
        "task_id": {
          "type": "string",
          "pattern": "^T[0-9]{3}$",
          "description": "フィードバック対象のタスクID"
        },
        "implementation_attempt": {
          "type": "integer",
          "minimum": 1,
          "description": "実装の試行回数"
        },
        "verification_results": {
          "type": "object",
          "required": ["passes_tests", "failed_tests", "suggestions"],
          "properties": {
            "passes_tests": {
              "type": "boolean",
              "description": "テストに合格したかどうか"
            },
            "failed_tests": {
              "type": "array",
              "items": {
                "type": "object",
                "required": ["test_name", "error"],
                "properties": {
                  "test_name": {
                    "type": "string",
                    "description": "失敗したテストの名前"
                  },
                  "error": {
                    "type": "string",
                    "description": "エラーメッセージ"
                  }
                }
              },
              "description": "失敗したテストのリスト"
            },
            "suggestions": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "改善提案のリスト"
            }
          }
        },
        "iteration_plan": {
          "type": "object",
          "required": ["focus_areas", "approach"],
          "properties": {
            "focus_areas": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "次のイテレーションでの焦点領域"
            },
            "approach": {
              "type": "string",
              "description": "次のイテレーションでのアプローチ"
            }
          }
        }
      }
    }
  }
}

================
File: src/schemas/session.schema.json
================
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "required": ["session_handover"],
  "properties": {
    "session_handover": {
      "type": "object",
      "required": ["project_id", "session_id", "session_timestamp", "project_state_summary", "next_session_focus"],
      "properties": {
        "project_id": {
          "type": "string",
          "description": "プロジェクトの一意識別子"
        },
        "session_id": {
          "type": "string",
          "description": "セッションの一意識別子（セッション終了時のGitコミットハッシュを使用）"
        },
        "previous_session_id": {
          "type": "string",
          "description": "前回のセッションID（連続性の確保）"
        },
        "session_timestamp": {
          "type": "string",
          "format": "date-time",
          "description": "セッション終了時刻（ISO 8601形式）"
        },
        "session_start_timestamp": {
          "type": "string",
          "format": "date-time",
          "description": "セッション開始時刻（ISO 8601形式）"
        },
        "project_state_summary": {
          "type": "object",
          "required": ["completed_tasks", "current_tasks", "pending_tasks"],
          "properties": {
            "completed_tasks": {
              "type": "array",
              "items": {
                "type": "string",
                "pattern": "^T[0-9]{3}$"
              },
              "description": "完了したタスクIDのリスト"
            },
            "current_tasks": {
              "type": "array",
              "items": {
                "type": "string",
                "pattern": "^T[0-9]{3}$"
              },
              "description": "現在進行中のタスクIDのリスト"
            },
            "pending_tasks": {
              "type": "array",
              "items": {
                "type": "string",
                "pattern": "^T[0-9]{3}$"
              },
              "description": "保留中のタスクIDのリスト"
            },
            "blocked_tasks": {
              "type": "array",
              "items": {
                "type": "string",
                "pattern": "^T[0-9]{3}$"
              },
              "description": "ブロックされているタスクIDのリスト"
            }
          }
        },
        "key_artifacts": {
          "type": "array",
          "items": {
            "type": "object",
            "required": ["path", "description"],
            "properties": {
              "path": {
                "type": "string",
                "description": "ファイルパス"
              },
              "description": {
                "type": "string",
                "description": "ファイルの説明"
              },
              "last_modified": {
                "type": "string",
                "format": "date-time",
                "description": "最終更新日時（Gitコミット時刻を基準）"
              },
              "git_status": {
                "type": "string",
                "enum": ["unchanged", "modified", "added", "deleted", "renamed"],
                "description": "Gitの状態"
              },
              "previous_path": {
                "type": "string",
                "description": "リネーム前のパス（git_statusがrenamedの場合）"
              },
              "related_tasks": {
                "type": "array",
                "items": {
                  "type": "string",
                  "pattern": "^T[0-9]{3}$"
                },
                "description": "関連するタスクID"
              },
              "importance": {
                "type": "string",
                "enum": ["high", "medium", "low"],
                "default": "medium",
                "description": "重要度"
              }
            }
          },
          "description": "重要なファイルとその状態"
        },
        "git_changes": {
          "type": "object",
          "properties": {
            "commits": {
              "type": "array",
              "items": {
                "type": "object",
                "required": ["hash", "message", "timestamp"],
                "properties": {
                  "hash": {
                    "type": "string",
                    "description": "コミットハッシュ"
                  },
                  "message": {
                    "type": "string",
                    "description": "コミットメッセージ"
                  },
                  "timestamp": {
                    "type": "string",
                    "format": "date-time",
                    "description": "コミット日時"
                  },
                  "related_tasks": {
                    "type": "array",
                    "items": {
                      "type": "string",
                      "pattern": "^T[0-9]{3}$"
                    },
                    "description": "関連するタスクID"
                  },
                  "author": {
                    "type": "string",
                    "description": "コミット作者"
                  }
                }
              },
              "description": "セッション中のコミット"
            },
            "summary": {
              "type": "object",
              "properties": {
                "files_added": {
                  "type": "integer",
                  "description": "追加されたファイル数"
                },
                "files_modified": {
                  "type": "integer",
                  "description": "変更されたファイル数"
                },
                "files_deleted": {
                  "type": "integer",
                  "description": "削除されたファイル数"
                },
                "lines_added": {
                  "type": "integer",
                  "description": "追加された行数"
                },
                "lines_deleted": {
                  "type": "integer",
                  "description": "削除された行数"
                }
              },
              "description": "変更の要約"
            }
          },
          "description": "Git変更の詳細"
        },
        "other_changes": {
          "type": "object",
          "properties": {
            "config_changes": {
              "type": "array",
              "items": {
                "type": "object",
                "required": ["config_type", "description"],
                "properties": {
                  "config_type": {
                    "type": "string",
                    "description": "設定タイプ"
                  },
                  "description": {
                    "type": "string",
                    "description": "変更の説明"
                  },
                  "timestamp": {
                    "type": "string",
                    "format": "date-time",
                    "description": "変更日時"
                  }
                }
              },
              "description": "設定変更"
            },
            "external_changes": {
              "type": "array",
              "items": {
                "type": "object",
                "required": ["system", "change_type", "description"],
                "properties": {
                  "system": {
                    "type": "string",
                    "description": "外部システム名"
                  },
                  "change_type": {
                    "type": "string",
                    "description": "変更タイプ"
                  },
                  "description": {
                    "type": "string",
                    "description": "変更の説明"
                  },
                  "timestamp": {
                    "type": "string",
                    "format": "date-time",
                    "description": "変更日時"
                  }
                }
              },
              "description": "外部システムの変更"
            }
          },
          "description": "Git以外の変更"
        },
        "current_challenges": {
          "type": "array",
          "items": {
            "type": "object",
            "required": ["description"],
            "properties": {
              "description": {
                "type": "string",
                "description": "課題の説明"
              },
              "related_tasks": {
                "type": "array",
                "items": {
                  "type": "string",
                  "pattern": "^T[0-9]{3}$"
                },
                "description": "関連するタスクID"
              },
              "priority": {
                "type": "integer",
                "minimum": 1,
                "maximum": 5,
                "default": 3,
                "description": "優先度（1:最低 〜 5:最高、ビジネス価値）"
              },
              "severity": {
                "type": "integer",
                "minimum": 1,
                "maximum": 5,
                "default": 3,
                "description": "重要度（1:最低 〜 5:最高、技術的影響）"
              },
              "status": {
                "type": "string",
                "enum": ["identified", "analyzing", "in_progress", "resolved", "wontfix"],
                "default": "identified",
                "description": "課題の状態"
              },
              "resolution_plan": {
                "type": "string",
                "description": "解決計画"
              }
            }
          },
          "description": "現在の課題のリスト"
        },
        "next_session_focus": {
          "type": "string",
          "description": "次のセッションでの焦点"
        },
        "action_items": {
          "type": "array",
          "items": {
            "type": "object",
            "required": ["description"],
            "properties": {
              "description": {
                "type": "string",
                "description": "アクションの説明"
              },
              "related_task": {
                "type": "string",
                "pattern": "^T[0-9]{3}$",
                "description": "関連するタスクID"
              },
              "priority": {
                "type": "integer",
                "minimum": 1,
                "maximum": 5,
                "default": 3,
                "description": "優先度（1:最低 〜 5:最高、ビジネス価値）"
              },
              "severity": {
                "type": "integer",
                "minimum": 1,
                "maximum": 5,
                "default": 3,
                "description": "重要度（1:最低 〜 5:最高、技術的影響）"
              },
              "due_date": {
                "type": "string",
                "format": "date",
                "description": "期限"
              },
              "assignee": {
                "type": "string",
                "description": "担当者"
              }
            }
          },
          "description": "次のセッションでのアクションアイテム"
        }
      }
    }
  }
}

================
File: src/schemas/task.schema.json
================
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "required": ["project", "original_request", "decomposed_tasks", "current_focus"],
  "properties": {
    "project": {
      "type": "string",
      "description": "プロジェクト名"
    },
    "original_request": {
      "type": "string",
      "description": "ユーザーからの元の指示"
    },
    "task_hierarchy": {
      "type": "object",
      "description": "タスクの階層構造（将来的な拡張用）",
      "properties": {
        "epics": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "epic_id": {
                "type": "string",
                "pattern": "^E[0-9]{3}$"
              },
              "title": { "type": "string" },
              "stories": {
                "type": "array",
                "items": {
                  "type": "string",
                  "pattern": "^S[0-9]{3}$"
                }
              }
            }
          }
        },
        "stories": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "story_id": {
                "type": "string",
                "pattern": "^S[0-9]{3}$"
              },
              "title": { "type": "string" },
              "tasks": {
                "type": "array",
                "items": {
                  "type": "string",
                  "pattern": "^T[0-9]{3}$"
                }
              }
            }
          }
        }
      }
    },
    "decomposed_tasks": {
      "type": "array",
      "items": {
        "type": "object",
        "required": ["id", "title", "description", "status", "dependencies"],
        "properties": {
          "id": {
            "type": "string",
            "pattern": "^T[0-9]{3}$",
            "description": "タスクID（T001形式）"
          },
          "title": {
            "type": "string",
            "description": "タスクタイトル"
          },
          "description": {
            "type": "string",
            "description": "タスクの詳細説明"
          },
          "status": {
            "type": "string",
            "enum": ["pending", "in_progress", "completed", "blocked"],
            "description": "タスクの状態"
          },
          "dependencies": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "task_id": {
                  "type": "string",
                  "pattern": "^T[0-9]{3}$"
                },
                "type": {
                  "type": "string",
                  "enum": ["strong", "weak"],
                  "default": "strong"
                }
              },
              "required": ["task_id"]
            },
            "description": "依存するタスクIDと依存タイプのリスト"
          },
          "priority": {
            "type": "integer",
            "minimum": 1,
            "maximum": 5,
            "default": 3,
            "description": "優先度（1:最低 〜 5:最高）"
          },
          "estimated_hours": {
            "type": "number",
            "minimum": 0,
            "description": "見積もり時間（時間単位）"
          },
          "progress_percentage": {
            "type": "integer",
            "minimum": 0,
            "maximum": 100,
            "default": 0,
            "description": "進捗率（0-100%）"
          },
          "progress_state": {
            "type": "string",
            "enum": [
              "not_started",
              "planning",
              "in_development",
              "implementation_complete",
              "in_review",
              "review_complete",
              "in_testing",
              "completed"
            ],
            "default": "not_started",
            "description": "進捗状態"
          },
          "git_commits": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "関連するGitコミットハッシュのリスト"
          }
        }
      }
    },
    "current_focus": {
      "type": "string",
      "pattern": "^T[0-9]{3}$",
      "description": "現在フォーカスしているタスクID"
    }
  }
}

================
File: src/templates/docs/feedback.json
================
{
  "feedback_loop": {
    "task_id": "T001",
    "implementation_attempt": 1,
    "verification_results": {
      "passes_tests": false,
      "failed_tests": [
        {
          "test_name": "テスト名",
          "error": "エラー内容"
        }
      ],
      "suggestions": [
        "改善提案1",
        "改善提案2"
      ]
    },
    "iteration_plan": {
      "focus_areas": ["焦点領域1", "焦点領域2"],
      "approach": "次の改善アプローチ"
    }
  }
}

================
File: src/templates/docs/session-handover-template.md
================
# セッション引継ぎドキュメント

## セッション情報
- **プロジェクト**: {{project_id}}
- **日時**: {{session_timestamp}}
- **セッション時間**: {{session_duration}}
- **セッションID**: {{session_id}}
- **前回セッションID**: {{previous_session_id}}

## プロジェクト状態サマリー
- **完了タスク**: {{completed_tasks_formatted}}
- **進行中タスク**: {{current_tasks_formatted}}
- **保留中タスク**: {{pending_tasks_formatted}}
- **ブロック中タスク**: {{blocked_tasks_formatted}}

## 実装済みの内容

{{implementation_summary}}

### 主な変更点
{{key_changes}}

### 重要なファイル
{{key_artifacts_formatted}}

## Git変更サマリー
- **コミット数**: {{commit_count}}
- **追加ファイル**: {{files_added}}
- **変更ファイル**: {{files_modified}}
- **削除ファイル**: {{files_deleted}}
- **追加行数**: {{lines_added}}
- **削除行数**: {{lines_deleted}}

### コミット履歴
{{commits_formatted}}

## その他の変更
{{other_changes_formatted}}

## 解決済みの課題
{{resolved_challenges}}

## 現在の課題
{{current_challenges_formatted}}

## 次のセッションでの実装手順

### 主な焦点
{{next_session_focus}}

### アクションアイテム
{{action_items_formatted}}

## 注意点と推奨事項
{{recommendations}}

================
File: src/templates/docs/session.json
================
{
  "session_handover": {
    "project_id": "knoa",
    "session_id": "abc123def456",
    "previous_session_id": "789ghi012jkl",
    "session_timestamp": "2025-03-20T15:30:00Z",
    "session_start_timestamp": "2025-03-20T13:45:00Z",
    "project_state_summary": {
      "completed_tasks": ["T001", "T002", "T003"],
      "current_tasks": ["T004"],
      "pending_tasks": ["T005", "T006"],
      "blocked_tasks": []
    },
    "key_artifacts": [
      {
        "path": "src/schemas/session.schema.json",
        "description": "セッションスキーマ定義",
        "last_modified": "2025-03-20T14:25:00Z",
        "git_status": "modified",
        "related_tasks": ["T004"],
        "importance": "high"
      },
      {
        "path": "src/utils/session-manager.js",
        "description": "セッション管理ユーティリティ",
        "last_modified": "2025-03-20T15:10:00Z",
        "git_status": "added",
        "related_tasks": ["T004"],
        "importance": "high"
      },
      {
        "path": "src/templates/docs/session.json",
        "description": "セッションテンプレート",
        "last_modified": "2025-03-20T14:30:00Z",
        "git_status": "renamed",
        "previous_path": "src/templates/session-template.json",
        "related_tasks": ["T004"],
        "importance": "medium"
      }
    ],
    "git_changes": {
      "commits": [
        {
          "hash": "abc123def456",
          "message": "セッションスキーマの拡張 #T004",
          "timestamp": "2025-03-20T15:20:00Z",
          "related_tasks": ["T004"],
          "author": "AI Developer"
        },
        {
          "hash": "def456ghi789",
          "message": "セッション管理ユーティリティの追加 #T004",
          "timestamp": "2025-03-20T14:50:00Z",
          "related_tasks": ["T004"],
          "author": "AI Developer"
        }
      ],
      "summary": {
        "files_added": 1,
        "files_modified": 2,
        "files_deleted": 0,
        "lines_added": 120,
        "lines_deleted": 30
      }
    },
    "other_changes": {
      "config_changes": [
        {
          "config_type": "environment",
          "description": "NODE_ENV=development に設定",
          "timestamp": "2025-03-20T13:50:00Z"
        }
      ],
      "external_changes": [
        {
          "system": "Issue Tracker",
          "change_type": "status_update",
          "description": "Issue #42 を 'In Progress' に更新",
          "timestamp": "2025-03-20T14:15:00Z"
        }
      ]
    },
    "current_challenges": [
      {
        "description": "セッションIDとGitコミットハッシュの関連付けの最適化",
        "related_tasks": ["T004"],
        "priority": 4,
        "severity": 3,
        "status": "in_progress",
        "resolution_plan": "複数コミットを1セッションとして扱うロジックの実装"
      },
      {
        "description": "複数のコミットがある場合のセッション管理",
        "related_tasks": ["T004"],
        "priority": 3,
        "severity": 4,
        "status": "analyzing",
        "resolution_plan": "セッション開始・終了時のコミットを明示的に記録する仕組みの導入"
      }
    ],
    "next_session_focus": "T005: フィードバックループの確立",
    "action_items": [
      {
        "description": "セッション管理ユーティリティのテスト作成",
        "related_task": "T004",
        "priority": 5,
        "severity": 4,
        "due_date": "2025-03-21",
        "assignee": "AI Developer"
      },
      {
        "description": "マークダウン生成機能の実装",
        "related_task": "T004",
        "priority": 4,
        "severity": 3,
        "due_date": "2025-03-22",
        "assignee": "AI Developer"
      }
    ]
  }
}

================
File: src/templates/docs/task.json
================
{
  "project": "サンプルプロジェクト",
  "original_request": "ユーザー登録機能とプロフィール編集機能を実装してください",
  "task_hierarchy": {
    "epics": [
      {
        "epic_id": "E001",
        "title": "ユーザー管理システム",
        "stories": ["S001", "S002"]
      }
    ],
    "stories": [
      {
        "story_id": "S001",
        "title": "ユーザー登録機能",
        "tasks": ["T001", "T002"]
      },
      {
        "story_id": "S002",
        "title": "プロフィール編集機能",
        "tasks": ["T003"]
      }
    ]
  },
  "decomposed_tasks": [
    {
      "id": "T001",
      "title": "ユーザーエンティティ設計",
      "description": "ユーザーの属性とメソッドを定義",
      "status": "completed",
      "dependencies": [],
      "priority": 5,
      "estimated_hours": 4,
      "progress_percentage": 100,
      "progress_state": "completed",
      "git_commits": ["abc123", "def456"]
    },
    {
      "id": "T002",
      "title": "ユーザー登録API実装",
      "description": "新規ユーザー登録エンドポイントの作成",
      "status": "in_progress",
      "dependencies": [
        {
          "task_id": "T001",
          "type": "strong"
        }
      ],
      "priority": 4,
      "estimated_hours": 8,
      "progress_percentage": 70,
      "progress_state": "in_review",
      "git_commits": ["ghi789"]
    },
    {
      "id": "T003",
      "title": "プロフィール編集API実装",
      "description": "既存ユーザー情報更新エンドポイントの作成",
      "status": "pending",
      "dependencies": [
        {
          "task_id": "T001",
          "type": "strong"
        },
        {
          "task_id": "T002",
          "type": "weak"
        }
      ],
      "priority": 3,
      "estimated_hours": 6,
      "progress_percentage": 0,
      "progress_state": "not_started",
      "git_commits": []
    }
  ],
  "current_focus": "T002"
}

================
File: src/templates/frontend/css/main.css
================
/**
 * @ai-metadata {
 *   "purpose": "メインCSSスタイルテンプレート",
 *   "dependencies": [],
 *   "lastModified": "2025-03-20"
 * }
 */

/* リセットとベーススタイル */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Arial', sans-serif;
  line-height: 1.6;
  color: #333;
  background-color: #f4f4f4;
}

/* レイアウト */
.container {
  width: 80%;
  margin: 0 auto;
  overflow: hidden;
}

/* ヘッダー */
header {
  background: #333;
  color: #fff;
  padding: 1rem;
}

header h1 {
  margin: 0;
}

nav ul {
  display: flex;
  list-style: none;
}

nav ul li {
  margin-right: 1rem;
}

nav ul li a {
  color: #fff;
  text-decoration: none;
}

/* メインコンテンツ */
main {
  padding: 2rem 0;
}

section {
  margin-bottom: 2rem;
}

/* フッター */
footer {
  background: #333;
  color: #fff;
  text-align: center;
  padding: 1rem;
  margin-top: 2rem;
}

/* レスポンシブデザイン */
@media (max-width: 768px) {
  .container {
    width: 95%;
  }
  
  nav ul {
    flex-direction: column;
  }
  
  nav ul li {
    margin-right: 0;
    margin-bottom: 0.5rem;
  }
}

================
File: src/templates/frontend/html/index.html
================
<!--
@ai-metadata {
  "purpose": "メインページテンプレート",
  "dependencies": ["../css/main.css", "../js/main.js"],
  "lastModified": "2025-03-20"
}
-->
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>プロジェクトタイトル</title>
  <link rel="stylesheet" href="styles/main.css">
</head>
<body>
  <header>
    <!-- ヘッダー -->
    <h1>プロジェクトタイトル</h1>
    <nav>
      <!-- ナビゲーション -->
      <ul>
        <li><a href="#">ホーム</a></li>
        <li><a href="#">機能</a></li>
        <li><a href="#">お問い合わせ</a></li>
      </ul>
    </nav>
  </header>

  <main>
    <!-- メインコンテンツ -->
    <section>
      <h2>セクションタイトル</h2>
      <p>コンテンツがここに入ります。</p>
    </section>
  </main>

  <footer>
    <!-- フッター -->
    <p>&copy; 2025 プロジェクト名</p>
  </footer>

  <script src="scripts/main.js"></script>
</body>
</html>

================
File: src/templates/frontend/js/main.js
================
/**
 * @ai-metadata {
 *   "purpose": "メインJavaScript機能テンプレート",
 *   "dependencies": [],
 *   "lastModified": "2025-03-20"
 * }
 */

// 初期化処理
document.addEventListener('DOMContentLoaded', function() {
  console.log('ページが読み込まれました');
  
  // イベントリスナーの設定
  setupEventListeners();
});

// イベントリスナー設定
function setupEventListeners() {
  // ここにイベントリスナーを追加
}

// データ処理関数
function processData(data) {
  // データ処理ロジック
  return data;
}

// ユーティリティ関数
function formatDate(date) {
  // 日付フォーマット処理
  return date.toISOString().split('T')[0];
}

================
File: src/templates/vba/Main.bas
================
' @ai-metadata {
'   "purpose": "メインVBAモジュールテンプレート",
'   "dependencies": [],
'   "exports": ["Initialize", "Main"],
'   "lastModified": "2025-03-20"
' }

Option Explicit

' 初期化処理
Public Sub Initialize()
    ' アプリケーションの初期化処理
    Debug.Print "アプリケーションを初期化しています..."
    
    ' ユーティリティの初期化
    Call InitializeUtilities
    
    ' フォームの表示
    ' UserForm1.Show
End Sub

' メイン処理
Public Sub Main()
    ' メイン処理ロジック
    Debug.Print "メイン処理を実行しています..."
    
    ' データ処理の呼び出し
    Call ProcessData
End Sub

' データ処理
Private Sub ProcessData()
    ' データ処理ロジック
    Debug.Print "データを処理しています..."
End Sub

' ユーティリティ初期化
Private Sub InitializeUtilities()
    ' ユーティリティの初期化処理
    Debug.Print "ユーティリティを初期化しています..."
End Sub

' エラーハンドリング
Public Sub HandleError(ByVal errNumber As Long, ByVal errDescription As String, ByVal errSource As String)
    ' エラー処理ロジック
    Debug.Print "エラーが発生しました: " & errNumber & " - " & errDescription & " (" & errSource & ")"
End Sub

================
File: src/utils/session-manager.js
================
/**
 * セッション管理ユーティリティ
 * 
 * セッション間の状態引継ぎを管理するためのユーティリティ関数群
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// スキーマの読み込み
const sessionSchema = require('../schemas/session.schema.json');

/**
 * セッション管理クラス
 */
class SessionManager {
  /**
   * コンストラクタ
   * @param {Object} options - オプション
   * @param {string} options.sessionsDir - セッションディレクトリのパス
   * @param {string} options.templateDir - テンプレートディレクトリのパス
   */
  constructor(options = {}) {
    this.sessionsDir = options.sessionsDir || path.join(process.cwd(), 'ai-context', 'sessions');
    this.templateDir = options.templateDir || path.join(process.cwd(), 'src', 'templates', 'docs');
    this.latestSessionPath = path.join(this.sessionsDir, 'latest-session.json');
    this.sessionHistoryDir = path.join(this.sessionsDir, 'session-history');
    
    // ディレクトリが存在しない場合は作成
    if (!fs.existsSync(this.sessionHistoryDir)) {
      fs.mkdirSync(this.sessionHistoryDir, { recursive: true });
    }
  }

  /**
   * セッションの検証
   * @param {Object} session - セッションオブジェクト
   * @returns {boolean} 検証結果
   */
  validateSession(session) {
    // 基本的な構造チェック
    if (!session || !session.session_handover) {
      console.error('セッションオブジェクトが不正です');
      return false;
    }

    const handover = session.session_handover;
    
    // 必須フィールドのチェック
    const requiredFields = ['project_id', 'session_id', 'session_timestamp', 'project_state_summary', 'next_session_focus'];
    for (const field of requiredFields) {
      if (!handover[field]) {
        console.error(`必須フィールド ${field} がありません`);
        return false;
      }
    }
    
    // project_state_summaryのチェック
    const stateSummary = handover.project_state_summary;
    if (!stateSummary.completed_tasks || !stateSummary.current_tasks || !stateSummary.pending_tasks) {
      console.error('project_state_summary の必須フィールドがありません');
      return false;
    }
    
    // タスクIDの形式チェック
    const taskPattern = /^T[0-9]{3}$/;
    const allTasks = [
      ...stateSummary.completed_tasks,
      ...stateSummary.current_tasks,
      ...stateSummary.pending_tasks,
      ...(stateSummary.blocked_tasks || [])
    ];
    
    for (const taskId of allTasks) {
      if (!taskPattern.test(taskId)) {
        console.error(`不正なタスクID形式です: ${taskId}`);
        return false;
      }
    }
    
    return true;
  }

  /**
   * 最新のセッションを取得
   * @returns {Object} 最新のセッション
   */
  getLatestSession() {
    try {
      if (fs.existsSync(this.latestSessionPath)) {
        const sessionData = fs.readFileSync(this.latestSessionPath, 'utf8');
        return JSON.parse(sessionData);
      }
    } catch (error) {
      console.error('最新のセッションの読み込みに失敗しました:', error);
    }
    return null;
  }

  /**
   * セッションIDでセッションを取得
   * @param {string} sessionId - セッションID
   * @returns {Object} セッション
   */
  getSessionById(sessionId) {
    try {
      // 最新のセッションをチェック
      const latestSession = this.getLatestSession();
      if (latestSession && latestSession.session_handover.session_id === sessionId) {
        return latestSession;
      }
      
      // 履歴からセッションを検索
      const sessionPath = path.join(this.sessionHistoryDir, `session-${sessionId}.json`);
      if (fs.existsSync(sessionPath)) {
        const sessionData = fs.readFileSync(sessionPath, 'utf8');
        return JSON.parse(sessionData);
      }
    } catch (error) {
      console.error(`セッションID ${sessionId} の取得に失敗しました:`, error);
    }
    return null;
  }

  /**
   * 新しいセッションを作成
   * @param {string} previousSessionId - 前回のセッションID
   * @returns {Object} 新しいセッション
   */
  createNewSession(previousSessionId) {
    try {
      let previousSession = null;
      
      if (previousSessionId) {
        previousSession = this.getSessionById(previousSessionId);
      } else {
        // 前回のセッションIDが指定されていない場合は最新のセッションを使用
        previousSession = this.getLatestSession();
        if (previousSession) {
          previousSessionId = previousSession.session_handover.session_id;
        }
      }
      
      // 現在のGitコミットハッシュを取得
      const sessionId = this._getCurrentGitCommitHash();
      const timestamp = new Date().toISOString();
      
      // 新しいセッションの基本構造
      const newSession = {
        session_handover: {
          project_id: previousSession ? previousSession.session_handover.project_id : 'knoa',
          session_id: sessionId,
          previous_session_id: previousSessionId || null,
          session_timestamp: timestamp,
          session_start_timestamp: timestamp,
          project_state_summary: {
            completed_tasks: [],
            current_tasks: [],
            pending_tasks: [],
            blocked_tasks: []
          },
          key_artifacts: [],
          git_changes: {
            commits: [],
            summary: {
              files_added: 0,
              files_modified: 0,
              files_deleted: 0,
              lines_added: 0,
              lines_deleted: 0
            }
          },
          other_changes: {
            config_changes: [],
            external_changes: []
          },
          current_challenges: [],
          next_session_focus: '',
          action_items: []
        }
      };
      
      // 前回のセッションから情報を引き継ぐ
      if (previousSession) {
        const prevHandover = previousSession.session_handover;
        
        // タスク状態の引き継ぎ
        newSession.session_handover.project_state_summary = {
          completed_tasks: [...prevHandover.project_state_summary.completed_tasks],
          current_tasks: [...prevHandover.project_state_summary.current_tasks],
          pending_tasks: [...prevHandover.project_state_summary.pending_tasks],
          blocked_tasks: [...(prevHandover.project_state_summary.blocked_tasks || [])]
        };
        
        // 課題の引き継ぎ（resolvedでないもの）
        if (Array.isArray(prevHandover.current_challenges)) {
          newSession.session_handover.current_challenges = prevHandover.current_challenges
            .filter(challenge => {
              return !challenge.status || 
                     (challenge.status !== 'resolved' && challenge.status !== 'wontfix');
            });
        }
        
        // アクションアイテムの引き継ぎ
        if (Array.isArray(prevHandover.action_items)) {
          newSession.session_handover.action_items = [...prevHandover.action_items];
        }
        
        // 次のセッションの焦点を引き継ぐ
        newSession.session_handover.next_session_focus = prevHandover.next_session_focus;
      }
      
      return newSession;
    } catch (error) {
      console.error('新しいセッションの作成に失敗しました:', error);
      return null;
    }
  }

  /**
   * セッションを保存
   * @param {Object} session - セッション
   * @param {boolean} isLatest - 最新のセッションとして保存するかどうか
   * @returns {boolean} 保存結果
   */
  saveSession(session, isLatest = true) {
    try {
      if (!this.validateSession(session)) {
        console.error('不正なセッションは保存できません');
        return false;
      }
      
      const sessionId = session.session_handover.session_id;
      
      // セッション履歴に保存
      const historyPath = path.join(this.sessionHistoryDir, `session-${sessionId}.json`);
      fs.writeFileSync(historyPath, JSON.stringify(session, null, 2), 'utf8');
      
      // 最新のセッションとして保存
      if (isLatest) {
        fs.writeFileSync(this.latestSessionPath, JSON.stringify(session, null, 2), 'utf8');
      }
      
      return true;
    } catch (error) {
      console.error('セッションの保存に失敗しました:', error);
      return false;
    }
  }

  /**
   * Gitコミットからセッション情報を生成
   * @param {string} startCommit - 開始コミットハッシュ
   * @param {string} endCommit - 終了コミットハッシュ
   * @returns {Object} セッション
   */
  createSessionFromGitCommits(startCommit, endCommit) {
    try {
      // 最新のセッションを取得
      const latestSession = this.getLatestSession();
      
      // 新しいセッションの基本構造
      const session = this.createNewSession(latestSession ? latestSession.session_handover.session_id : null);
      
      if (!session) {
        return null;
      }
      
      // セッションIDを終了コミットハッシュに設定
      session.session_handover.session_id = endCommit;
      
      // コミット情報を取得
      const commits = this._getCommitsBetween(startCommit, endCommit);
      session.session_handover.git_changes.commits = commits;
      
      // 変更サマリーを計算
      const summary = this.calculateChangeSummary(commits);
      session.session_handover.git_changes.summary = summary;
      
      // セッションの開始時刻と終了時刻を設定
      if (commits.length > 0) {
        // 最初のコミットの時刻を開始時刻に
        session.session_handover.session_start_timestamp = commits[commits.length - 1].timestamp;
        // 最後のコミットの時刻を終了時刻に
        session.session_handover.session_timestamp = commits[0].timestamp;
      }
      
      // key_artifactの候補を取得
      const keyArtifacts = this.getKeyArtifactCandidates(commits);
      session.session_handover.key_artifacts = keyArtifacts;
      
      return session;
    } catch (error) {
      console.error('Gitコミットからのセッション生成に失敗しました:', error);
      return null;
    }
  }

  /**
   * セッションをGit変更で更新
   * @param {string} sessionId - セッションID
   * @param {Array} commits - コミット情報の配列
   * @returns {Object} 更新されたセッション
   */
  updateSessionWithGitChanges(sessionId, commits) {
    try {
      const session = this.getSessionById(sessionId);
      
      if (!session) {
        console.error(`セッションID ${sessionId} が見つかりません`);
        return null;
      }
      
      // コミット情報を更新
      session.session_handover.git_changes.commits = commits;
      
      // 変更サマリーを計算
      const summary = this.calculateChangeSummary(commits);
      session.session_handover.git_changes.summary = summary;
      
      // key_artifactの候補を更新
      const keyArtifacts = this.getKeyArtifactCandidates(commits);
      session.session_handover.key_artifacts = keyArtifacts;
      
      return session;
    } catch (error) {
      console.error('セッションのGit変更更新に失敗しました:', error);
      return null;
    }
  }

  /**
   * key_artifactを追加
   * @param {string} sessionId - セッションID
   * @param {Object} artifact - key_artifact
   * @returns {Object} 更新されたセッション
   */
  addKeyArtifact(sessionId, artifact) {
    try {
      const session = this.getSessionById(sessionId);
      
      if (!session) {
        console.error(`セッションID ${sessionId} が見つかりません`);
        return null;
      }
      
      // 必須フィールドのチェック
      if (!artifact.path || !artifact.description) {
        console.error('key_artifactには path と description が必要です');
        return null;
      }
      
      // 既存のkey_artifactを検索
      const existingIndex = session.session_handover.key_artifacts.findIndex(a => a.path === artifact.path);
      
      if (existingIndex >= 0) {
        // 既存のkey_artifactを更新
        session.session_handover.key_artifacts[existingIndex] = {
          ...session.session_handover.key_artifacts[existingIndex],
          ...artifact
        };
      } else {
        // 新しいkey_artifactを追加
        session.session_handover.key_artifacts.push(artifact);
      }
      
      return session;
    } catch (error) {
      console.error('key_artifactの追加に失敗しました:', error);
      return null;
    }
  }

  /**
   * 課題を追加
   * @param {string} sessionId - セッションID
   * @param {Object} challenge - 課題
   * @returns {Object} 更新されたセッション
   */
  addChallenge(sessionId, challenge) {
    try {
      const session = this.getSessionById(sessionId);
      
      if (!session) {
        console.error(`セッションID ${sessionId} が見つかりません`);
        return null;
      }
      
      // 必須フィールドのチェック
      if (!challenge.description) {
        console.error('challengeには description が必要です');
        return null;
      }
      
      // 既存の課題を検索
      const existingIndex = session.session_handover.current_challenges.findIndex(
        c => c.description === challenge.description
      );
      
      if (existingIndex >= 0) {
        // 既存の課題を更新
        session.session_handover.current_challenges[existingIndex] = {
          ...session.session_handover.current_challenges[existingIndex],
          ...challenge
        };
      } else {
        // 新しい課題を追加
        session.session_handover.current_challenges.push(challenge);
      }
      
      return session;
    } catch (error) {
      console.error('課題の追加に失敗しました:', error);
      return null;
    }
  }

  /**
   * アクションアイテムを追加
   * @param {string} sessionId - セッションID
   * @param {Object} actionItem - アクションアイテム
   * @returns {Object} 更新されたセッション
   */
  addActionItem(sessionId, actionItem) {
    try {
      const session = this.getSessionById(sessionId);
      
      if (!session) {
        console.error(`セッションID ${sessionId} が見つかりません`);
        return null;
      }
      
      // 必須フィールドのチェック
      if (!actionItem.description) {
        console.error('actionItemには description が必要です');
        return null;
      }
      
      // 既存のアクションアイテムを検索
      const existingIndex = session.session_handover.action_items.findIndex(
        a => a.description === actionItem.description
      );
      
      if (existingIndex >= 0) {
        // 既存のアクションアイテムを更新
        session.session_handover.action_items[existingIndex] = {
          ...session.session_handover.action_items[existingIndex],
          ...actionItem
        };
      } else {
        // 新しいアクションアイテムを追加
        session.session_handover.action_items.push(actionItem);
      }
      
      return session;
    } catch (error) {
      console.error('アクションアイテムの追加に失敗しました:', error);
      return null;
    }
  }

  /**
   * セッション間の差分を取得
   * @param {string} sessionId1 - セッションID1
   * @param {string} sessionId2 - セッションID2
   * @returns {Object} 差分情報
   */
  getSessionDiff(sessionId1, sessionId2) {
    try {
      const session1 = this.getSessionById(sessionId1);
      const session2 = this.getSessionById(sessionId2);
      
      if (!session1 || !session2) {
        console.error('セッションが見つかりません');
        return null;
      }
      
      const handover1 = session1.session_handover;
      const handover2 = session2.session_handover;
      
      // タスク状態の差分
      const taskDiff = {
        completed: {
          added: handover2.project_state_summary.completed_tasks.filter(
            t => !handover1.project_state_summary.completed_tasks.includes(t)
          ),
          removed: handover1.project_state_summary.completed_tasks.filter(
            t => !handover2.project_state_summary.completed_tasks.includes(t)
          )
        },
        current: {
          added: handover2.project_state_summary.current_tasks.filter(
            t => !handover1.project_state_summary.current_tasks.includes(t)
          ),
          removed: handover1.project_state_summary.current_tasks.filter(
            t => !handover2.project_state_summary.current_tasks.includes(t)
          )
        },
        pending: {
          added: handover2.project_state_summary.pending_tasks.filter(
            t => !handover1.project_state_summary.pending_tasks.includes(t)
          ),
          removed: handover1.project_state_summary.pending_tasks.filter(
            t => !handover2.project_state_summary.pending_tasks.includes(t)
          )
        },
        blocked: {
          added: (handover2.project_state_summary.blocked_tasks || []).filter(
            t => !(handover1.project_state_summary.blocked_tasks || []).includes(t)
          ),
          removed: (handover1.project_state_summary.blocked_tasks || []).filter(
            t => !(handover2.project_state_summary.blocked_tasks || []).includes(t)
          )
        }
      };
      
      // key_artifactの差分
      const artifactDiff = {
        added: handover2.key_artifacts.filter(
          a2 => !handover1.key_artifacts.some(a1 => a1.path === a2.path)
        ),
        modified: handover2.key_artifacts.filter(
          a2 => handover1.key_artifacts.some(
            a1 => a1.path === a2.path && a1.last_modified !== a2.last_modified
          )
        ),
        removed: handover1.key_artifacts.filter(
          a1 => !handover2.key_artifacts.some(a2 => a2.path === a1.path)
        )
      };
      
      // 課題の差分
      const challengeDiff = {
        added: handover2.current_challenges.filter(
          c2 => !handover1.current_challenges.some(c1 => c1.description === c2.description)
        ),
        resolved: handover1.current_challenges.filter(
          c1 => !handover2.current_challenges.some(c2 => c2.description === c1.description)
        ),
        updated: handover2.current_challenges.filter(
          c2 => handover1.current_challenges.some(
            c1 => c1.description === c2.description && 
                  (c1.status !== c2.status || c1.priority !== c2.priority || c1.severity !== c2.severity)
          )
        )
      };
      
      // アクションアイテムの差分
      const actionItemDiff = {
        added: handover2.action_items.filter(
          a2 => !handover1.action_items.some(a1 => a1.description === a2.description)
        ),
        completed: handover1.action_items.filter(
          a1 => !handover2.action_items.some(a2 => a2.description === a1.description)
        ),
        updated: handover2.action_items.filter(
          a2 => handover1.action_items.some(
            a1 => a1.description === a2.description && 
                  (a1.priority !== a2.priority || a1.severity !== a2.severity || a1.due_date !== a2.due_date)
          )
        )
      };
      
      return {
        taskDiff,
        artifactDiff,
        challengeDiff,
        actionItemDiff,
        focusChanged: handover1.next_session_focus !== handover2.next_session_focus
      };
    } catch (error) {
      console.error('セッション差分の取得に失敗しました:', error);
      return null;
    }
  }

  /**
   * マークダウン形式の引継ぎドキュメントを生成
   * @param {string} sessionId - セッションID
   * @param {string} templateName - テンプレート名
   * @returns {string} マークダウン形式の引継ぎドキュメント
   */
  generateSessionHandoverMarkdown(sessionId, templateName = 'session-handover-template.md') {
    try {
      const session = this.getSessionById(sessionId);
      
      if (!session) {
        console.error(`セッションID ${sessionId} が見つかりません`);
        return null;
      }
      
      // テンプレートを読み込む
      const templatePath = path.join(this.templateDir, templateName);
      let template = fs.readFileSync(templatePath, 'utf8');
      
      const handover = session.session_handover;
      
      // セッション情報
      template = template.replace(/{{project_id}}/g, handover.project_id);
      template = template.replace(/{{session_timestamp}}/g, this._formatDateTime(handover.session_timestamp));
      template = template.replace(/{{session_id}}/g, handover.session_id);
      template = template.replace(/{{previous_session_id}}/g, handover.previous_session_id || 'なし');
      
      // セッション時間の計算
      const sessionDuration = this._calculateSessionDuration(
        handover.session_start_timestamp,
        handover.session_timestamp
      );
      template = template.replace(/{{session_duration}}/g, sessionDuration);
      
      // プロジェクト状態サマリー
      template = template.replace(
        /{{completed_tasks_formatted}}/g,
        this._formatTaskList(handover.project_state_summary.completed_tasks)
      );
      template = template.replace(
        /{{current_tasks_formatted}}/g,
        this._formatTaskList(handover.project_state_summary.current_tasks)
      );
      template = template.replace(
        /{{pending_tasks_formatted}}/g,
        this._formatTaskList(handover.project_state_summary.pending_tasks)
      );
      template = template.replace(
        /{{blocked_tasks_formatted}}/g,
        this._formatTaskList(handover.project_state_summary.blocked_tasks || [])
      );
      
      // 実装サマリー
      const implementationSummary = this._generateImplementationSummary(handover);
      template = template.replace(/{{implementation_summary}}/g, implementationSummary);
      
      // 主な変更点
      const keyChanges = this._generateKeyChanges(handover);
      template = template.replace(/{{key_changes}}/g, keyChanges);
      
      // 重要なファイル
      template = template.replace(
        /{{key_artifacts_formatted}}/g,
        this._formatKeyArtifacts(handover.key_artifacts)
      );
      
      // Git変更サマリー
      template = template.replace(/{{commit_count}}/g, handover.git_changes.commits.length.toString());
      template = template.replace(/{{files_added}}/g, handover.git_changes.summary.files_added.toString());
      template = template.replace(/{{files_modified}}/g, handover.git_changes.summary.files_modified.toString());
      template = template.replace(/{{files_deleted}}/g, handover.git_changes.summary.files_deleted.toString());
      template = template.replace(/{{lines_added}}/g, handover.git_changes.summary.lines_added.toString());
      template = template.replace(/{{lines_deleted}}/g, handover.git_changes.summary.lines_deleted.toString());
      
      // コミット履歴
      template = template.replace(
        /{{commits_formatted}}/g,
        this._formatCommits(handover.git_changes.commits)
      );
      
      // その他の変更
      template = template.replace(
        /{{other_changes_formatted}}/g,
        this._formatOtherChanges(handover.other_changes)
      );
      
      // 解決済みの課題
      const resolvedChallenges = this._generateResolvedChallenges(handover);
      template = template.replace(/{{resolved_challenges}}/g, resolvedChallenges);
      
      // 現在の課題
      template = template.replace(
        /{{current_challenges_formatted}}/g,
        this._formatChallenges(handover.current_challenges)
      );
      
      // 次のセッションの焦点
      template = template.replace(/{{next_session_focus}}/g, handover.next_session_focus);
      
      // アクションアイテム
      template = template.replace(
        /{{action_items_formatted}}/g,
        this._formatActionItems(handover.action_items)
      );
      
      // 推奨事項
      const recommendations = this._generateRecommendations(handover);
      template = template.replace(/{{recommendations}}/g, recommendations);
      
      return template;
    } catch (error) {
      console.error('マークダウン生成に失敗しました:', error);
      return null;
    }
  }

  /**
   * key_artifactの候補を取得
   * @param {Array} commits - コミット情報の配列
   * @returns {Array} key_artifactの候補
   */
  getKeyArtifactCandidates(commits) {
    try {
      // 変更されたファイルの情報を収集
      const fileChanges = {};
      
      for (const commit of commits) {
        // コミットで変更されたファイルを取得
        const changedFiles = this._getChangedFilesInCommit(commit.hash);
        
        for (const file of changedFiles) {
          if (!fileChanges[file.path]) {
            fileChanges[file.path] = {
              path: file.path,
              git_status: file.status,
              previous_path: file.previous_path,
              last_modified: commit.timestamp,
              related_tasks: [...(commit.related_tasks || [])],
              commit_count: 1
            };
          } else {
            // 既存のファイル情報を更新
            fileChanges[file.path].commit_count += 1;
            fileChanges[file.path].last_modified = commit.timestamp;
            
            // 関連タスクを追加（重複を除去）
            if (commit.related_tasks) {
              for (const task of commit.related_tasks) {
                if (!fileChanges[file.path].related_tasks.includes(task)) {
                  fileChanges[file.path].related_tasks.push(task);
                }
              }
            }
          }
        }
      }
      
      // 重要度を評価
      const keyArtifacts = Object.values(fileChanges).map(file => {
        // 重要度の評価基準
        let importance = 'medium';
        
        // コミット回数が多いファイルは重要
        if (file.commit_count > 2) {
          importance = 'high';
        }
        
        // 特定のパターンに一致するファイルは重要
        const importantPatterns = [
          /\.schema\.json$/,
          /^src\/utils\/.+\.js$/,
          /^src\/templates\/.+\.md$/,
          /^ai-context\/.+\.json$/
        ];
        
        for (const pattern of importantPatterns) {
          if (pattern.test(file.path)) {
            importance = 'high';
            break;
          }
        }
        
        // ファイルの説明を生成
        let description = this._generateFileDescription(file.path);
        
        return {
          path: file.path,
          description,
          last_modified: file.last_modified,
          git_status: file.git_status,
          previous_path: file.previous_path,
          related_tasks: file.related_tasks,
          importance
        };
      });
      
      // 重要度でソート（high, medium, lowの順）
      keyArtifacts.sort((a, b) => {
        const importanceOrder = { high: 0, medium: 1, low: 2 };
        return importanceOrder[a.importance] - importanceOrder[b.importance];
      });
      
      return keyArtifacts;
    } catch (error) {
      console.error('key_artifact候補の取得に失敗しました:', error);
      return [];
    }
  }

  /**
   * 変更サマリーを計算
   * @param {Array} commits - コミット情報の配列
   * @returns {Object} 変更サマリー
   */
  calculateChangeSummary(commits) {
    try {
      let summary = {
        files_added: 0,
        files_modified: 0,
        files_deleted: 0,
        lines_added: 0,
        lines_deleted: 0
      };
      
      // 変更されたファイルを追跡（重複カウントを避けるため）
      const processedFiles = new Set();
      
      for (const commit of commits) {
        // コミットの差分情報を取得
        const diffStats = this._getCommitDiffStats(commit.hash);
        
        for (const file of diffStats.files) {
          // 既に処理済みのファイルはスキップ
          if (processedFiles.has(file.path)) {
            continue;
          }
          
          processedFiles.add(file.path);
          
          // ファイルの状態に応じてカウント
          if (file.status === 'added') {
            summary.files_added += 1;
          } else if (file.status === 'modified' || file.status === 'renamed') {
            summary.files_modified += 1;
          } else if (file.status === 'deleted') {
            summary.files_deleted += 1;
          }
        }
        
        // 行数の変更を加算
        summary.lines_added += diffStats.lines_added;
        summary.lines_deleted += diffStats.lines_deleted;
      }
      
      return summary;
    } catch (error) {
      console.error('変更サマリーの計算に失敗しました:', error);
      return {
        files_added: 0,
        files_modified: 0,
        files_deleted: 0,
        lines_added: 0,
        lines_deleted: 0
      };
    }
  }

  /**
   * コミットメッセージからタスクIDを抽出
   * @param {string} message - コミットメッセージ
   * @returns {Array} タスクIDの配列
   */
  extractTaskIdsFromCommitMessage(message) {
    try {
      const taskPattern = /#T[0-9]{3}/g;
      const matches = message.match(taskPattern) || [];
      
      // '#'を除去してタスクIDのみを返す
      return matches.map(match => match.substring(1));
    } catch (error) {
      console.error('タスクIDの抽出に失敗しました:', error);
      return [];
    }
  }

  /**
   * アクションアイテムとタスクを関連付け
   * @param {string} sessionId - セッションID
   * @returns {Object} 更新されたセッション
   */
  linkActionItemsToTasks(sessionId) {
    try {
      const session = this.getSessionById(sessionId);
      
      if (!session) {
        console.error(`セッションID ${sessionId} が見つかりません`);
        return null;
      }
      
      const handover = session.session_handover;
      
      // 現在のタスクを取得
      const allTasks = [
        ...handover.project_state_summary.completed_tasks,
        ...handover.project_state_summary.current_tasks,
        ...handover.project_state_summary.pending_tasks,
        ...(handover.project_state_summary.blocked_tasks || [])
      ];
      
      // アクションアイテムを更新
      for (let i = 0; i < handover.action_items.length; i++) {
        const actionItem = handover.action_items[i];
        
        // 関連タスクが設定されていない場合は、説明からタスクIDを抽出
        if (!actionItem.related_task) {
          const taskPattern = /T[0-9]{3}/g;
          const matches = actionItem.description.match(taskPattern) || [];
          
          if (matches.length > 0) {
            // 最初に見つかったタスクIDを使用
            const taskId = matches[0];
            
            // タスクが存在するか確認
            if (allTasks.includes(taskId)) {
              handover.action_items[i].related_task = taskId;
            }
          }
        }
      }
      
      return session;
    } catch (error) {
      console.error('アクションアイテムとタスクの関連付けに失敗しました:', error);
      return null;
    }
  }

  /**
   * 現在のGitコミットハッシュを取得
   * @returns {string} コミットハッシュ
   * @private
   */
  _getCurrentGitCommitHash() {
    try {
      return execSync('git rev-parse HEAD').toString().trim();
    } catch (error) {
      console.error('Gitコミットハッシュの取得に失敗しました:', error);
      return `unknown-${Date.now()}`;
    }
  }

  /**
   * 2つのコミット間のコミット情報を取得
   * @param {string} startCommit - 開始コミットハッシュ
   * @param {string} endCommit - 終了コミットハッシュ
   * @returns {Array} コミット情報の配列
   * @private
   */
  _getCommitsBetween(startCommit, endCommit) {
    try {
      const command = `git log ${startCommit}..${endCommit} --pretty=format:"%H|%s|%ai|%an"`;
      const output = execSync(command).toString().trim();
      
      if (!output) {
        return [];
      }
      
      return output.split('\n').map(line => {
        const [hash, message, timestamp, author] = line.split('|');
        const related_tasks = this.extractTaskIdsFromCommitMessage(message);
        
        return {
          hash,
          message,
          timestamp: new Date(timestamp).toISOString(),
          related_tasks,
          author
        };
      });
    } catch (error) {
      console.error('コミット情報の取得に失敗しました:', error);
      return [];
    }
  }

  /**
   * コミットで変更されたファイルを取得
   * @param {string} commitHash - コミットハッシュ
   * @returns {Array} 変更されたファイルの配列
   * @private
   */
  _getChangedFilesInCommit(commitHash) {
    try {
      const command = `git show --name-status --format="" ${commitHash}`;
      const output = execSync(command).toString().trim();
      
      if (!output) {
        return [];
      }
      
      return output.split('\n').map(line => {
        const [status, path, newPath] = line.split('\t');
        
        let fileStatus = 'modified';
        if (status === 'A') fileStatus = 'added';
        else if (status === 'D') fileStatus = 'deleted';
        else if (status === 'R') fileStatus = 'renamed';
        
        return {
          path: newPath || path,
          status: fileStatus,
          previous_path: status === 'R' ? path : undefined
        };
      });
    } catch (error) {
      console.error('変更ファイルの取得に失敗しました:', error);
      return [];
    }
  }

  /**
   * コミットの差分統計を取得
   * @param {string} commitHash - コミットハッシュ
   * @returns {Object} 差分統計
   * @private
   */
  _getCommitDiffStats(commitHash) {
    try {
      // 変更されたファイルを取得
      const files = this._getChangedFilesInCommit(commitHash);
      
      // 行数の変更を取得
      const command = `git show --numstat --format="" ${commitHash}`;
      const output = execSync(command).toString().trim();
      
      let lines_added = 0;
      let lines_deleted = 0;
      
      if (output) {
        output.split('\n').forEach(line => {
          const [added, deleted] = line.split('\t');
          
          // バイナリファイルなどで '-' が返ってくる場合はスキップ
          if (added !== '-' && deleted !== '-') {
            lines_added += parseInt(added, 10) || 0;
            lines_deleted += parseInt(deleted, 10) || 0;
          }
        });
      }
      
      return {
        files,
        lines_added,
        lines_deleted
      };
    } catch (error) {
      console.error('差分統計の取得に失敗しました:', error);
      return {
        files: [],
        lines_added: 0,
        lines_deleted: 0
      };
    }
  }

  /**
   * ファイルの説明を生成
   * @param {string} filePath - ファイルパス
   * @returns {string} ファイルの説明
   * @private
   */
  _generateFileDescription(filePath) {
    // ファイル名を取得
    const fileName = path.basename(filePath);
    
    // ファイルの種類に基づいて説明を生成
    if (filePath.endsWith('.schema.json')) {
      return `${fileName.replace('.schema.json', '')}のスキーマ定義`;
    } else if (filePath.endsWith('.json')) {
      return `${fileName.replace('.json', '')}の設定ファイル`;
    } else if (filePath.endsWith('.js')) {
      if (filePath.includes('/utils/')) {
        return `${fileName.replace('.js', '')}ユーティリティ`;
      } else if (filePath.includes('/templates/')) {
        return `${fileName.replace('.js', '')}テンプレート`;
      } else {
        return `${fileName.replace('.js', '')}モジュール`;
      }
    } else if (filePath.endsWith('.md')) {
      return `${fileName.replace('.md', '')}ドキュメント`;
    } else if (filePath.endsWith('.test.js')) {
      return `${fileName.replace('.test.js', '')}のテスト`;
    } else {
      return fileName;
    }
  }

  /**
   * タスクリストをフォーマット
   * @param {Array} tasks - タスクIDの配列
   * @returns {string} フォーマットされたタスクリスト
   * @private
   */
  _formatTaskList(tasks) {
    if (!tasks || tasks.length === 0) {
      return 'なし';
    }
    
    return tasks.map(task => `\`${task}\``).join(', ');
  }

  /**
   * key_artifactをフォーマット
   * @param {Array} artifacts - key_artifactの配列
   * @returns {string} フォーマットされたkey_artifact
   * @private
   */
  _formatKeyArtifacts(artifacts) {
    if (!artifacts || artifacts.length === 0) {
      return 'なし';
    }
    
    return artifacts.map(artifact => {
      let status = '';
      switch (artifact.git_status) {
        case 'added':
          status = '📝 新規';
          break;
        case 'modified':
          status = '✏️ 変更';
          break;
        case 'deleted':
          status = '🗑️ 削除';
          break;
        case 'renamed':
          status = '🔄 リネーム';
          break;
        default:
          status = '📄';
      }
      
      let importance = '';
      switch (artifact.importance) {
        case 'high':
          importance = '🔴';
          break;
        case 'medium':
          importance = '🟡';
          break;
        case 'low':
          importance = '🟢';
          break;
      }
      
      let result = `- ${status} ${importance} **\`${artifact.path}\`**: ${artifact.description}`;
      
      if (artifact.git_status === 'renamed' && artifact.previous_path) {
        result += ` (旧: \`${artifact.previous_path}\`)`;
      }
      
      if (artifact.related_tasks && artifact.related_tasks.length > 0) {
        result += ` (関連タスク: ${artifact.related_tasks.map(t => `\`${t}\``).join(', ')})`;
      }
      
      return result;
    }).join('\n');
  }

  /**
   * コミットをフォーマット
   * @param {Array} commits - コミットの配列
   * @returns {string} フォーマットされたコミット
   * @private
   */
  _formatCommits(commits) {
    if (!commits || commits.length === 0) {
      return 'なし';
    }
    
    return commits.map(commit => {
      let result = `- **${commit.hash.substring(0, 7)}**: ${commit.message}`;
      
      if (commit.related_tasks && commit.related_tasks.length > 0) {
        result += ` (関連タスク: ${commit.related_tasks.map(t => `\`${t}\``).join(', ')})`;
      }
      
      result += ` - ${this._formatDateTime(commit.timestamp)} by ${commit.author}`;
      
      return result;
    }).join('\n');
  }

  /**
   * その他の変更をフォーマット
   * @param {Object} otherChanges - その他の変更
   * @returns {string} フォーマットされたその他の変更
   * @private
   */
  _formatOtherChanges(otherChanges) {
    if (!otherChanges) {
      return 'なし';
    }
    
    let result = '';
    
    // 設定変更
    if (otherChanges.config_changes && otherChanges.config_changes.length > 0) {
      result += '### 設定変更\n\n';
      result += otherChanges.config_changes.map(change => {
        return `- **${change.config_type}**: ${change.description} (${this._formatDateTime(change.timestamp)})`;
      }).join('\n');
      result += '\n\n';
    }
    
    // 外部システムの変更
    if (otherChanges.external_changes && otherChanges.external_changes.length > 0) {
      result += '### 外部システムの変更\n\n';
      result += otherChanges.external_changes.map(change => {
        return `- **${change.system}** (${change.change_type}): ${change.description} (${this._formatDateTime(change.timestamp)})`;
      }).join('\n');
      result += '\n\n';
    }
    
    return result || 'なし';
  }

  /**
   * 課題をフォーマット
   * @param {Array} challenges - 課題の配列
   * @returns {string} フォーマットされた課題
   * @private
   */
  _formatChallenges(challenges) {
    if (!challenges || challenges.length === 0) {
      return 'なし';
    }
    
    return challenges.map(challenge => {
      let priority = '⭐'.repeat(challenge.priority || 3);
      let severity = '🔥'.repeat(challenge.severity || 3);
      
      let status = '';
      switch (challenge.status) {
        case 'identified':
          status = '🔍 特定済み';
          break;
        case 'analyzing':
          status = '🔬 分析中';
          break;
        case 'in_progress':
          status = '🚧 対応中';
          break;
        case 'resolved':
          status = '✅ 解決済み';
          break;
        case 'wontfix':
          status = '⏩ 対応しない';
          break;
        default:
          status = '🔍 特定済み';
      }
      
      let result = `- ${status} **${challenge.description}**`;
      
      if (challenge.related_tasks && challenge.related_tasks.length > 0) {
        result += ` (関連タスク: ${challenge.related_tasks.map(t => `\`${t}\``).join(', ')})`;
      }
      
      result += `\n  - 優先度: ${priority} | 重要度: ${severity}`;
      
      if (challenge.resolution_plan) {
        result += `\n  - 解決計画: ${challenge.resolution_plan}`;
      }
      
      return result;
    }).join('\n\n');
  }

  /**
   * アクションアイテムをフォーマット
   * @param {Array} actionItems - アクションアイテムの配列
   * @returns {string} フォーマットされたアクションアイテム
   * @private
   */
  _formatActionItems(actionItems) {
    if (!actionItems || actionItems.length === 0) {
      return 'なし';
    }
    
    return actionItems.map(item => {
      let priority = '⭐'.repeat(item.priority || 3);
      let severity = '🔥'.repeat(item.severity || 3);
      
      let result = `- **${item.description}**`;
      
      if (item.related_task) {
        result += ` (関連タスク: \`${item.related_task}\`)`;
      }
      
      result += `\n  - 優先度: ${priority} | 重要度: ${severity}`;
      
      if (item.due_date) {
        result += ` | 期限: ${item.due_date}`;
      }
      
      if (item.assignee) {
        result += ` | 担当: ${item.assignee}`;
      }
      
      return result;
    }).join('\n\n');
  }

  /**
   * 実装サマリーを生成
   * @param {Object} handover - セッション引継ぎ情報
   * @returns {string} 実装サマリー
   * @private
   */
  _generateImplementationSummary(handover) {
    // コミット情報から実装内容を要約
    if (!handover.git_changes || !handover.git_changes.commits || handover.git_changes.commits.length === 0) {
      return '実装内容はありません。';
    }
    
    // コミットメッセージから実装内容を抽出
    const commitMessages = handover.git_changes.commits.map(commit => commit.message);
    
    // 重複を除去
    const uniqueMessages = [...new Set(commitMessages)];
    
    // タスクIDを除去してメッセージを整形
    const cleanMessages = uniqueMessages.map(message => {
      return message.replace(/#T[0-9]{3}/g, '').trim();
    });
    
    return cleanMessages.map(message => `- ${message}`).join('\n');
  }

  /**
   * 主な変更点を生成
   * @param {Object} handover - セッション引継ぎ情報
   * @returns {string} 主な変更点
   * @private
   */
  _generateKeyChanges(handover) {
    // 変更サマリーから主な変更点を抽出
    const summary = handover.git_changes.summary;
    
    if (summary.files_added === 0 && summary.files_modified === 0 && summary.files_deleted === 0) {
      return '主な変更点はありません。';
    }
    
    const changes = [];
    
    if (summary.files_added > 0) {
      changes.push(`- ${summary.files_added}個のファイルを追加`);
    }
    
    if (summary.files_modified > 0) {
      changes.push(`- ${summary.files_modified}個のファイルを変更`);
    }
    
    if (summary.files_deleted > 0) {
      changes.push(`- ${summary.files_deleted}個のファイルを削除`);
    }
    
    if (summary.lines_added > 0 || summary.lines_deleted > 0) {
      changes.push(`- ${summary.lines_added}行追加、${summary.lines_deleted}行削除`);
    }
    
    return changes.join('\n');
  }

  /**
   * 解決済みの課題を生成
   * @param {Object} handover - セッション引継ぎ情報
   * @returns {string} 解決済みの課題
   * @private
   */
  _generateResolvedChallenges(handover) {
    // 解決済みの課題を抽出
    const resolvedChallenges = handover.current_challenges.filter(
      challenge => challenge.status === 'resolved'
    );
    
    if (resolvedChallenges.length === 0) {
      return '解決済みの課題はありません。';
    }
    
    return resolvedChallenges.map(challenge => {
      let result = `- ✅ **${challenge.description}**`;
      
      if (challenge.related_tasks && challenge.related_tasks.length > 0) {
        result += ` (関連タスク: ${challenge.related_tasks.map(t => `\`${t}\``).join(', ')})`;
      }
      
      return result;
    }).join('\n');
  }

  /**
   * 推奨事項を生成
   * @param {Object} handover - セッション引継ぎ情報
   * @returns {string} 推奨事項
   * @private
   */
  _generateRecommendations(handover) {
    const recommendations = [];
    
    // 優先度の高い課題がある場合
    const highPriorityChallenges = handover.current_challenges.filter(
      challenge => (challenge.priority >= 4 || challenge.severity >= 4) && 
                  challenge.status !== 'resolved' && 
                  challenge.status !== 'wontfix'
    );
    
    if (highPriorityChallenges.length > 0) {
      recommendations.push('- 優先度または重要度の高い課題に注意してください。');
    }
    
    // 期限の近いアクションアイテムがある場合
    const today = new Date();
    const nearDueActionItems = handover.action_items.filter(item => {
      if (!item.due_date) return false;
      
      const dueDate = new Date(item.due_date);
      const diffDays = Math.ceil((dueDate - today) / (1000 * 60 * 60 * 24));
      
      return diffDays <= 3;
    });
    
    if (nearDueActionItems.length > 0) {
      recommendations.push('- 期限の近いアクションアイテムがあります。優先的に対応してください。');
    }
    
    // 変更の多いファイルがある場合
    const highChangeFiles = handover.key_artifacts.filter(
      artifact => artifact.importance === 'high'
    );
    
    if (highChangeFiles.length > 0) {
      recommendations.push('- 重要度の高いファイルに変更が集中しています。慎重にレビューしてください。');
    }
    
    // 推奨事項がない場合
    if (recommendations.length === 0) {
      return '特に注意すべき点はありません。';
    }
    
    return recommendations.join('\n');
  }

  /**
   * 日時をフォーマット
   * @param {string} dateTimeString - ISO 8601形式の日時文字列
   * @returns {string} フォーマットされた日時
   * @private
   */
  _formatDateTime(dateTimeString) {
    try {
      const date = new Date(dateTimeString);
      return date.toLocaleString('ja-JP', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });
    } catch (error) {
      return dateTimeString;
    }
  }

  /**
   * セッション時間を計算
   * @param {string} startTime - 開始時刻
   * @param {string} endTime - 終了時刻
   * @returns {string} セッション時間
   * @private
   */
  _calculateSessionDuration(startTime, endTime) {
    try {
      const start = new Date(startTime);
      const end = new Date(endTime);
      
      const durationMs = end - start;
      const hours = Math.floor(durationMs / (1000 * 60 * 60));
      const minutes = Math.floor((durationMs % (1000 * 60 * 60)) / (1000 * 60));
      
      return `${hours}時間${minutes}分`;
    } catch (error) {
      return '不明';
    }
  }
}

module.exports = { SessionManager };

================
File: src/utils/task-manager.js
================
/**
 * タスク管理ユーティリティ
 * 
 * タスクの検証、依存関係管理、進捗管理、Git連携などの機能を提供します。
 */

// 進捗状態の定義
const PROGRESS_STATES = {
  not_started: {
    description: "タスクがまだ開始されていない状態",
    default_percentage: 0
  },
  planning: {
    description: "タスクの計画段階",
    default_percentage: 10
  },
  in_development: {
    description: "開発中の状態",
    default_percentage: 30
  },
  implementation_complete: {
    description: "実装が完了した状態",
    default_percentage: 60
  },
  in_review: {
    description: "レビュー中の状態",
    default_percentage: 70
  },
  review_complete: {
    description: "レビューが完了した状態",
    default_percentage: 80
  },
  in_testing: {
    description: "テスト中の状態",
    default_percentage: 90
  },
  completed: {
    description: "タスクが完了した状態",
    default_percentage: 100
  }
};

// 状態遷移の定義
const STATE_TRANSITIONS = {
  not_started: ["planning", "in_development"],
  planning: ["in_development"],
  in_development: ["implementation_complete", "in_review"],
  implementation_complete: ["in_review"],
  in_review: ["review_complete", "in_development"],
  review_complete: ["in_testing"],
  in_testing: ["completed", "in_development"],
  completed: []
};

/**
 * タスクを検証する
 * @param {Object} task - 検証するタスク
 * @returns {Object} 検証結果（isValid: boolean, errors: string[]）
 */
function validateTask(task) {
  const errors = [];
  
  // 必須フィールドの検証
  const requiredFields = ["id", "title", "description", "status", "dependencies"];
  for (const field of requiredFields) {
    if (!task[field]) {
      errors.push(`${field}は必須フィールドです`);
    }
  }
  
  // IDの形式検証
  if (task.id && !task.id.match(/^T[0-9]{3}$/)) {
    errors.push("IDはT001形式である必要があります");
  }
  
  // ステータスの検証
  const validStatuses = ["pending", "in_progress", "completed", "blocked"];
  if (task.status && !validStatuses.includes(task.status)) {
    errors.push(`ステータスは${validStatuses.join(", ")}のいずれかである必要があります`);
  }
  
  // 優先度の検証
  if (task.priority !== undefined) {
    if (!Number.isInteger(task.priority) || task.priority < 1 || task.priority > 5) {
      errors.push("優先度は1から5の整数である必要があります");
    }
  }
  
  // 見積もり時間の検証
  if (task.estimated_hours !== undefined) {
    if (typeof task.estimated_hours !== "number" || task.estimated_hours < 0) {
      errors.push("見積もり時間は0以上の数値である必要があります");
    }
  }
  
  // 進捗率の検証
  if (task.progress_percentage !== undefined) {
    if (!Number.isInteger(task.progress_percentage) || 
        task.progress_percentage < 0 || 
        task.progress_percentage > 100) {
      errors.push("進捗率は0から100の整数である必要があります");
    }
  }
  
  // 進捗状態の検証
  if (task.progress_state !== undefined) {
    if (!Object.keys(PROGRESS_STATES).includes(task.progress_state)) {
      errors.push(`進捗状態は${Object.keys(PROGRESS_STATES).join(", ")}のいずれかである必要があります`);
    }
  }
  
  // 依存関係の検証
  if (Array.isArray(task.dependencies)) {
    for (const dep of task.dependencies) {
      if (typeof dep === "object") {
        if (!dep.task_id) {
          errors.push("依存関係オブジェクトにはtask_idが必要です");
        } else if (!dep.task_id.match(/^T[0-9]{3}$/)) {
          errors.push("依存関係のtask_idはT001形式である必要があります");
        }
        
        if (dep.type && !["strong", "weak"].includes(dep.type)) {
          errors.push("依存関係のtypeはstrongまたはweakである必要があります");
        }
      } else if (typeof dep === "string") {
        if (!dep.match(/^T[0-9]{3}$/)) {
          errors.push("依存関係のIDはT001形式である必要があります");
        }
      } else {
        errors.push("依存関係は文字列またはオブジェクトである必要があります");
      }
    }
  }
  
  return {
    isValid: errors.length === 0,
    errors
  };
}

/**
 * 依存関係を検証する
 * @param {string} taskId - 検証するタスクのID
 * @param {Array} tasks - すべてのタスクの配列
 * @returns {Object} 検証結果（isValid: boolean, errors: string[], warnings: string[]）
 */
function checkDependencies(taskId, tasks) {
  const errors = [];
  const warnings = [];
  const visited = new Set();
  const path = [];
  
  // タスクを検索
  const task = tasks.find(t => t.id === taskId);
  if (!task) {
    errors.push(`タスク${taskId}が見つかりません`);
    return { isValid: false, errors, warnings };
  }
  
  // 循環依存のチェック
  function checkCyclicDependency(currentTaskId) {
    if (path.includes(currentTaskId)) {
      const cycle = [...path.slice(path.indexOf(currentTaskId)), currentTaskId];
      return `循環依存が検出されました: ${cycle.join(" -> ")}`;
    }
    
    if (visited.has(currentTaskId)) {
      return null;
    }
    
    visited.add(currentTaskId);
    path.push(currentTaskId);
    
    const currentTask = tasks.find(t => t.id === currentTaskId);
    if (!currentTask) {
      return `タスク${currentTaskId}が見つかりません`;
    }
    
    const dependencies = currentTask.dependencies || [];
    for (const dep of dependencies) {
      const depTaskId = typeof dep === "object" ? dep.task_id : dep;
      const error = checkCyclicDependency(depTaskId);
      if (error) {
        return error;
      }
    }
    
    path.pop();
    return null;
  }
  
  const cyclicError = checkCyclicDependency(taskId);
  if (cyclicError) {
    errors.push(cyclicError);
  }
  
  // 依存タスクの存在チェック
  const dependencies = task.dependencies || [];
  for (const dep of dependencies) {
    const depTaskId = typeof dep === "object" ? dep.task_id : dep;
    const depTask = tasks.find(t => t.id === depTaskId);
    
    if (!depTask) {
      errors.push(`依存タスク${depTaskId}が見つかりません`);
      continue;
    }
    
    // 強い依存関係の場合、依存タスクが完了しているかチェック
    const depType = typeof dep === "object" ? (dep.type || "strong") : "strong";
    if (depType === "strong" && depTask.status !== "completed") {
      warnings.push(`強い依存関係のタスク${depTaskId}がまだ完了していません`);
    }
  }
  
  return {
    isValid: errors.length === 0,
    errors,
    warnings
  };
}

/**
 * タスクの進捗率を計算する
 * @param {string} taskId - 計算するタスクのID
 * @param {Array} tasks - すべてのタスクの配列
 * @returns {number} 計算された進捗率（0-100）
 */
function calculateProgress(taskId, tasks) {
  const task = tasks.find(t => t.id === taskId);
  if (!task) {
    return 0;
  }
  
  // 進捗率が明示的に設定されている場合はそれを返す
  if (task.progress_percentage !== undefined) {
    return task.progress_percentage;
  }
  
  // 進捗状態から進捗率を推定
  if (task.progress_state && PROGRESS_STATES[task.progress_state]) {
    return PROGRESS_STATES[task.progress_state].default_percentage;
  }
  
  // ステータスから進捗率を推定
  switch (task.status) {
    case "completed":
      return 100;
    case "in_progress":
      return 50;
    case "blocked":
      return 25;
    case "pending":
    default:
      return 0;
  }
}

/**
 * ステータスでタスクをフィルタリングする
 * @param {Array} tasks - すべてのタスクの配列
 * @param {string} status - フィルタリングするステータス
 * @returns {Array} フィルタリングされたタスクの配列
 */
function getTasksByStatus(tasks, status) {
  return tasks.filter(task => task.status === status);
}

/**
 * 進捗状態でタスクをフィルタリングする
 * @param {Array} tasks - すべてのタスクの配列
 * @param {string} progressState - フィルタリングする進捗状態
 * @returns {Array} フィルタリングされたタスクの配列
 */
function getTasksByProgressState(tasks, progressState) {
  return tasks.filter(task => task.progress_state === progressState);
}

/**
 * Gitコミットハッシュでタスクをフィルタリングする
 * @param {Array} tasks - すべてのタスクの配列
 * @param {string} commitHash - フィルタリングするコミットハッシュ
 * @returns {Array} フィルタリングされたタスクの配列
 */
function getTasksWithGitCommit(tasks, commitHash) {
  return tasks.filter(task => 
    Array.isArray(task.git_commits) && 
    task.git_commits.includes(commitHash)
  );
}

/**
 * タスクの進捗を更新する
 * @param {string} taskId - 更新するタスクのID
 * @param {number} percentage - 新しい進捗率
 * @param {string} state - 新しい進捗状態
 * @param {Array} tasks - すべてのタスクの配列
 * @returns {Object} 更新結果（success: boolean, message: string, updatedTasks: Array）
 */
function updateTaskProgress(taskId, percentage, state, tasks) {
  const taskIndex = tasks.findIndex(t => t.id === taskId);
  if (taskIndex === -1) {
    return {
      success: false,
      message: `タスク${taskId}が見つかりません`,
      updatedTasks: tasks
    };
  }
  
  const task = { ...tasks[taskIndex] };
  const updatedTasks = [...tasks];
  let message = "";
  
  // 進捗率の更新
  if (percentage !== undefined) {
    if (percentage < 0 || percentage > 100 || !Number.isInteger(percentage)) {
      return {
        success: false,
        message: "進捗率は0から100の整数である必要があります",
        updatedTasks
      };
    }
    
    task.progress_percentage = percentage;
    message += `進捗率を${percentage}%に更新しました。`;
    
    // 進捗率に基づいてステータスを推定
    if (percentage === 100 && task.status !== "completed") {
      task.status = "completed";
      message += "ステータスを完了に更新しました。";
    } else if (percentage > 0 && task.status === "pending") {
      task.status = "in_progress";
      message += "ステータスを進行中に更新しました。";
    }
  }
  
  // 進捗状態の更新
  if (state !== undefined) {
    if (!Object.keys(PROGRESS_STATES).includes(state)) {
      return {
        success: false,
        message: `進捗状態は${Object.keys(PROGRESS_STATES).join(", ")}のいずれかである必要があります`,
        updatedTasks
      };
    }
    
    // 状態遷移の検証
    const currentState = task.progress_state || "not_started";
    if (state !== currentState && !STATE_TRANSITIONS[currentState].includes(state)) {
      return {
        success: false,
        message: `${currentState}から${state}への状態遷移は許可されていません`,
        updatedTasks
      };
    }
    
    task.progress_state = state;
    message += `進捗状態を${state}に更新しました。`;
    
    // 進捗状態に基づいて進捗率を推定（明示的に設定されていない場合）
    if (percentage === undefined) {
      task.progress_percentage = PROGRESS_STATES[state].default_percentage;
      message += `進捗率を${task.progress_percentage}%に更新しました。`;
    }
    
    // 進捗状態に基づいてステータスを推定
    if (state === "completed" && task.status !== "completed") {
      task.status = "completed";
      message += "ステータスを完了に更新しました。";
    } else if (state !== "not_started" && task.status === "pending") {
      task.status = "in_progress";
      message += "ステータスを進行中に更新しました。";
    }
  }
  
  updatedTasks[taskIndex] = task;
  
  return {
    success: true,
    message: message || "タスクの進捗を更新しました",
    updatedTasks
  };
}

/**
 * タスクにGitコミットを関連付ける
 * @param {string} taskId - 関連付けるタスクのID
 * @param {string} commitHash - 関連付けるコミットハッシュ
 * @param {Array} tasks - すべてのタスクの配列
 * @returns {Object} 更新結果（success: boolean, message: string, updatedTasks: Array）
 */
function addGitCommitToTask(taskId, commitHash, tasks) {
  const taskIndex = tasks.findIndex(t => t.id === taskId);
  if (taskIndex === -1) {
    return {
      success: false,
      message: `タスク${taskId}が見つかりません`,
      updatedTasks: tasks
    };
  }
  
  const task = { ...tasks[taskIndex] };
  const updatedTasks = [...tasks];
  
  // git_commitsフィールドがない場合は作成
  if (!Array.isArray(task.git_commits)) {
    task.git_commits = [];
  }
  
  // 既に関連付けられている場合は何もしない
  if (task.git_commits.includes(commitHash)) {
    return {
      success: true,
      message: `コミット${commitHash}は既にタスク${taskId}に関連付けられています`,
      updatedTasks
    };
  }
  
  // コミットを追加
  task.git_commits.push(commitHash);
  updatedTasks[taskIndex] = task;
  
  return {
    success: true,
    message: `コミット${commitHash}をタスク${taskId}に関連付けました`,
    updatedTasks
  };
}

/**
 * コミットメッセージからタスクIDを抽出する
 * @param {string} commitMessage - コミットメッセージ
 * @returns {Array} 抽出されたタスクIDの配列
 */
function extractTaskIdsFromCommitMessage(commitMessage) {
  const regex = /#(T[0-9]{3})/g;
  const matches = commitMessage.match(regex) || [];
  return matches.map(match => match.substring(1)); // #を除去
}

/**
 * 次の進捗状態を取得する
 * @param {string} currentState - 現在の進捗状態
 * @returns {string|null} 次の進捗状態、または選択肢がない場合はnull
 */
function getNextProgressState(currentState) {
  if (!currentState || !STATE_TRANSITIONS[currentState]) {
    return "not_started";
  }
  
  const nextStates = STATE_TRANSITIONS[currentState];
  return nextStates.length > 0 ? nextStates[0] : null;
}

/**
 * 古い形式のタスクを新しい形式に変換する
 * @param {Object} oldTask - 古い形式のタスク
 * @returns {Object} 新しい形式のタスク
 */
function migrateTaskToNewFormat(oldTask) {
  const newTask = { ...oldTask };
  
  // 依存関係の変換
  if (Array.isArray(oldTask.dependencies)) {
    newTask.dependencies = oldTask.dependencies.map(dep => {
      if (typeof dep === "string") {
        return {
          task_id: dep,
          type: "strong"
        };
      }
      return dep;
    });
  }
  
  // デフォルト値の設定
  if (newTask.priority === undefined) {
    newTask.priority = 3;
  }
  
  if (newTask.progress_percentage === undefined) {
    newTask.progress_percentage = newTask.status === "completed" ? 100 : 
                                 newTask.status === "in_progress" ? 50 : 0;
  }
  
  if (newTask.progress_state === undefined) {
    newTask.progress_state = newTask.status === "completed" ? "completed" : 
                            newTask.status === "in_progress" ? "in_development" : "not_started";
  }
  
  if (!Array.isArray(newTask.git_commits)) {
    newTask.git_commits = [];
  }
  
  return newTask;
}

module.exports = {
  validateTask,
  checkDependencies,
  calculateProgress,
  getTasksByStatus,
  getTasksByProgressState,
  getTasksWithGitCommit,
  updateTaskProgress,
  addGitCommitToTask,
  extractTaskIdsFromCommitMessage,
  getNextProgressState,
  migrateTaskToNewFormat,
  PROGRESS_STATES,
  STATE_TRANSITIONS
};
